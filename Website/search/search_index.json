{
    "docs": [
        {
            "location": "/", 
            "text": "The Team 0 Group, LLC\n\n\nWinners of the 2018 ME210 Mechatronics Bracket!\n\n\n\n\nThe Team: Meet the Members\n\n\n\n\nJoe Sunde\n         | Mechanical Engineering Co-term\n\n\nChristopher Sauer\n | Computer Science Co-term\n\n\nShalini Ranmuthu\n  | Electrical Engineering Master\u2019s\n\n\nKyle Feldmann\n     | Mechanical Engineering Co-term\n\n\n(from left)\n\n\nThe Objective: Game-Play and Rules\n\n\nME 210 is a course that gives students an opportunity to dive into the world of mechatronics (intelligent electro-mechanical design).  The course\u2019s final assignment is a 3.5 week team project to create an autonomous bot that completes a series of tasks and can compete against the other 24 bots in the class.\n\n\nThis year\u2019s task was startup themed, the goal of the robot was to dispense balls (Buzzwords) into seesaw like boxes (Funding Rounds and Patent Offices) and to control at least two of them(A and B, or PO and B) to open the gate. Once the gate is open the bot can drive through and enter their opponent\u2019s starting area (Startup Garage) and win the game (acquire the opponent).\n\n\nThe robot can only carry 4 balls at a time and can only reload in the Incubator. The robot only has the walls, black and grey tape on the ground, and a series of IR beacons of different frequency and duty cycle to base its gameplay off of. The task must be completed in 2 minutes and 10 seconds, at which time the robots shut off and whoever has placed the most balls in the Funding Rounds wins.\n\n\n\n\nThe Map of \u2018Silicon Valley.\u2019\n\n\nThe Evidence: Competition Results\n\n\n\n\nOur robot, configured as in competition.\n\n\n\n\nVictory in the bracket.\n\n\nFinal Round\n\n\n\n\nSemi-Final Round\n\n\n\n\nQuarter-Final Round\n\n\n\n\nSweet 16 Round\n\n\n\n\nThe Strategy: Discussing Design Choices\n\n\nThe group set out from the start with the goal of not only meeting the minimum design requirements but also being competitive in the showcase at the end. While there is no grading benefit to winning, we wanted to have a robot the whole group was proud to share with the class and beyond Stanford. We quickly realized based on our motor selection from the free bin that one of the strengths of the robot was the available motor torque and speed. We knew it would drain power quickly, but provided we had enough power, we would be able to execute a strategy based on making quick maneuvers. Initial testing off a DC power source led us to decide to step down the gear ratio from the gear head slightly in our chain drive. We built a robot around coordinate motion to eliminate time lost in turning, and most importantly, we decided that using a line following strategy would be needlessly slow and instead opted for a physical wall following strategy. This decision had some major benefits. The first is that on a linked coordinate drive system any wander in the system (ie tendency to drive on a curve rather than line) is not correctable by the robot drive system. However, the walls of the course itself allow the edges of the robot to correct its trajectory if the cross drive provides some small amount of force holding the robot against the wall. This is perfect since the funding round bins are located against the wall. Instead of having to stop at each bin and advance from the tracking line, we could execute a \u201cdrive by\u201d ball deposit strategy. The coordinate motion strategy also eliminated the need to execute a turn to get through the gate further reducing the cycle time for the robot. Wall tracking allows another benefit in that simple limit switches can be used for tracking the position of the robot. Unlike tape sensors with varying thresholds based on light conditions, tape color, and cracks, limit switches offer a very binary measure of whether the robot has found a limit of the board.\n\n\nAfter many close readings of the rules we decided on a competition strategy that included tipping Funding Round A (but not depositing any balls), depositing 3 balls into the Patent Office( ensuring that it would remain in our favor at least until the other team reloaded), and depositing a required 1 ball in Funding Round B while tipping it.\n\n\nWe would repeat this process as many times as we felt would be entirely reliably, as occasionally we would count an extra line before Funding Round A or misfire a ball. We established that two runs through would be enough to ensure that we would have control of at least one of the rounds, so on our subsequent reloads we strategized to dispense 4 balls into the patent office to protect it, and only tip the Funding Rounds.\n\n\nWith our speed and tipping power, we knew that no teams could beat us outright, and that we could tip 25 balls or more from the opponent's side, so we were not worried about teams who filled our Funding Round B only, and not worried about teams taking both A and B while we were reloading.\n\n\nThis methodology differed crucially from our checkoff where we were required to deposit balls in A and B and tipping had no bearing.\n\n\nThe Takeaway: Lessons Learned\n\n\nOne of the pitfalls that is often an easy trap for engineers is the belief that because we have the tools to implement complex solutions these methods are the best way to solve a problem. Choosing simpler solutions early on that didn\u2019t require lots of tuning increased reliability and preserved flexibility for the new challenges and strategies that came up once the game board was finalized.\n\n\nA perfect example of this is the implementation of threshold sensing using photo-transistors or more neatly tape sensors. In the lab we learned how to design and tune these systems using signal conditioning circuits and comparators with hysteresis. Having this immediate knowledge it is tempting to build a robot that only views its world through tape sensors and IR beacons. However, limit switches are incredibly reliable and provide a useful binary response that takes some threshold calibration to get from IR phototransistors. For a robot living in a world bounded by insurmountable walls, is it necessary to make use of this technology? Our answer we found was yes but to much less a degree than many teams chose. Our initial design included four or six tape sensors. What we quickly realized was that we could simply use one and still be much faster and more efficient than most designs that used several.\n\n\nA second major lesson was that friction in real systems can be a real wild card. A significant number of robots in the competition or in practice would seemingly get inexplicably grabbed by walls or cracks in the floor or turn unexpectedly. We experienced this the night before the competition testing some final lines of code. The robot would get hung up on the return to the incubator which we determined was because of a small piece of tape on the wall. To this end we found that for our wall following design, bearing casters on the face really helped provide a predictable response.\n\n\nThere is often not one right answer, but at the end of the day, the team does need to make a decision and execute it well. For multiple components of the design there were competing design strategies. However, once the team decided on one, the whole group worked to implement it and continue designing from that point. Sometimes decisions you think are questionable at the beginning end up being much better than you thought. When multiple good options are available and there\u2019s disagreement within the team, it\u2019s critical to reach consensus and all commit to designing a single solution.\n\n\nFinally building something for a theoretical challenge is more difficult than building for what is in front of you. The late arrival of the game board forced us to make our best guesses about what to expect. One thing we did not account for was how close the beacons would be to the edge of the game board. We also could not predict exactly how the funding rounds would respond to a tipping force. As designers, we had to figure out how to build in flexibility in the physical robot itself and how we structured the code. Defining an architecture early on allowed changes at these later stages to be much simpler and less stressful.\n\n\n\n\nElectrical and Mechanical Design\n\n\n\n\nSchematic\n\n\n\n\n\n\nSchematic for entire robot.\n\n\nTeensy Pinout\n\n\n\n\n\n\n\n\nteensy PIN #\n\n\nteensy PIN type\n\n\nconnecting PIN #\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\n0\n\n\nDIGITAL_OUT\n\n\ndriver1 in1\n\n\nN/S motor+\n\n\n\n\n\n\n1\n\n\nDIGITAL_OUT\n\n\ndriver1 in2\n\n\nN/S motor-\n\n\n\n\n\n\n2\n\n\nDIGITAL_OUT\n\n\ndriver1 in3\n\n\nE/W motor+\n\n\n\n\n\n\n3\n\n\nDIGITAL_OUT\n\n\ndriver1 in4\n\n\nE/W motor-\n\n\n\n\n\n\n4\n\n\nPWM\n\n\ndriver1 en1\n\n\nN/S motor\n\n\n\n\n\n\n5\n\n\nPWM\n\n\ndriver1 en2\n\n\nE/W motor\n\n\n\n\n\n\n6\n\n\nDIGITAL_OUT\n\n\ndriver2 in1\n\n\nramp sol top\n\n\n\n\n\n\n7\n\n\nDIGITAL_OUT\n\n\ndriver2 in2\n\n\nramp sol bottom\n\n\n\n\n\n\n8\n\n\nDIGITAL_OUT\n\n\ndriver2 in3\n\n\ntipper motor\n\n\n\n\n\n\n9\n\n\nDIGITAL_OUT\n\n\ndriver2 in4\n\n\ntipper motor\n\n\n\n\n\n\n10\n\n\nPWM\n\n\ndriver2 en2\n\n\ntipper motor\n\n\n\n\n\n\n11\n\n\nINPUT_PULLUP\n\n\nlimit switch\n\n\nramp switch top\n\n\n\n\n\n\n12\n\n\nINPUT_PULLUP\n\n\nlimit switch\n\n\nramp switch bottom\n\n\n\n\n\n\n14\n\n\nANALOG_INPUT\n\n\nphototransistor\n\n\ntape sensor\n\n\n\n\n\n\n15\n\n\nINPUT_PULLUP\n\n\nlimit switch N\n\n\nwall bumper\n\n\n\n\n\n\n16\n\n\nINPUT_PULLUP\n\n\nlimit switch E\n\n\nreloading bumper\n\n\n\n\n\n\n17\n\n\nINPUT_PULLUP\n\n\nlimit switch S\n\n\nstart/back bumper\n\n\n\n\n\n\n18\n\n\nANALOG_INPUT\n\n\nop-amp output\n\n\nbeacon sensor\n\n\n\n\n\n\n\n\nRobot Subsystems\n\n\nPower Supply and Drivers\n\n\nPower to the robot was provided by two Gens Ace 7.2V 3000mAh batteries connected in series to form the 14V supply (although actual voltage was slightly higher). A 15A breaker switch was placed in series with the power supply and functioned as an overall power switch. The power supply was connected to both of the L298N drivers, which are rated for at least a 35V supply. The L298N driver boards also have a built-in 5V voltage regulator, and one of these regulator outputs was used to power the Teensy, the tape sensing circuit, and the beacon sensing circuit. A 220uF bypass capacitor was used to stabilize the 5V power line.\n\n\nThe L298N drivers themselves are dual H bridge motor drivers, which means that we could control 4 total motors with this setup. We ended up driving 2 wheel motors, 1 tipper arm motor, and 2 solenoids (8 total outputs) using 8 inputs and 4 enable lines (wired as shown in the schematic).\n\n\nDrivetrain\n\n\nWe decided to have the robot execute coordinate movement instead of a more traditional isolated two wheel drive. Mechanically, we decided to use two motors with two full width drive axles mechanically linking the advance ratio of each set of drive wheels. We used omni-directional wheels to allow this type of drive system. One of the concerns early on with this system was making sure all wheels are uniformly in contact with the ground at all times to ensure the robot would drive in a straight orthogonal grid. We used a captive design to place pillars holding shoulder bushings and 4 mechanical supports per axle (two closely placed around each drive wheel) The accuracy and repeatability of CAD driven laser cutting allowed easy alignment of the bearing axes and ensuring that all four wheels would contact the ground well. We sized the drive wheels to be 4 inches on one axis and 3.25 inches on the other axis so that the axles could cross each other without interference. We prototyped the drivetrain train levels to confirm our design would work before continuing with the upper level design. Initially, there was enough tolerance variation that the axles would bind in the bushing, so the bearings were opened up a few thousandths of an inch to allow free rolling. The second deck of the robot was the integrated electronics and drive motor deck. This area was more accessible with more space and was thus easier to work in. The axles were connected through the deck with a chain drive system to the DC motors mounted on brackets on top of the second deck. The brackets were mounted in slots to allow proper chain tensioning after the chain was assembled.\n\n\nWall Tracking\n\n\nAfter being forewarned about the pitfalls of line sensing, we developed another motion sensing system for robust tracking. The wall tracking method consisted of three limit switches mounted to the lower level of the robot on the front, right and rear sides of our bot, in a way that when they are fully engaged the roller sits flush with the outside edge of the robot.\n\n\nWe used wall tracking to trigger our interrupts, and to ensure that we were reaching our desired destinations for dropping balls, tipping, reloading, and finishing a round.\n\n\nBall Dispensing\n\n\nFrom the start we focused on a simple, robust ball dispensing system. Our ball dispensing system used a pvc tube mounted to a vertical duron board. This tube has holes for a limit switch and a solenoid. The limit switch was used to sense if balls were loaded into the tube, and the solenoid to quickly and reliably dispense balls. The reason we decided to use a solenoid rather than a servo was that it allowed us to more quickly dispense balls while driving quickly, and gave us the ability to dispense one ball at a time if necessary.\n\n\nWe also decided to have two separate ball dispensing systems so that we could selectively load balls depending on the desired functionality. While giving the robot information based on game events was not allowed in a rules update, our system let us load balls in a specific pattern so that we could dispense in different bins after each reload. We ended up using a strategy of dispensing 3 balls into the Patent Office and one into Funding Round B for the first two reloading cycles, and 4 into the Patent Office for each successive reloading cycle.\n\n\nWe also used modified syringes to quickly reload our dispensing tubes cutting reloading time by about 1.5 seconds over hand-loading.\n\n\nTape Sensing\n\n\nWe used tape sensing as a secondary sensing system to determine when we were in front of the funding rounds, patent office, or gate. We designed for enough room to integrate three sensors along the bottom of our robot along a threaded rod, but ended up only needing one on the left side of the robot to sense the grey tape marking the funding round locations and the tape marking the gate location. We decided to put the sensor on the left of the robot to give us time to drive and shoot near full speed.\n\n\nThe tape sensor itself consists of the OP265 photodiode and the OP535 phototransistor. The diode drop was measured to be 1.16V. In order to limit the current through the diode to the recommended 40mA and account for some safety margin, we rounded the drop down to \n1V\n, leaving \n5V-1V=4V\n to drop in series with the LED. This resulted in a required resistance value of  \n\\frac{4V}{40mA} = 100\\Omega\n. From the OP535 datasheet current curves, we initially used a \n1k\\Omega\n resistor in a sourcing configuration, but we found upon experimentation that a \n10k\\Omega\n resistor gave a better range.\n\n\nThe low-clearance skirt for our robot was able to block most light and our sensor remained in calibration for our purposes after a few initial calibration tests before checkoff.  The values from these calibration tests are shown in the table below. With the calibrated thresholds, we could detect the white game board as well as black, grey, and green tape. We also filtered out cracks and other small objects by sampling at least twice per grey tape width and then checking that we read two of the same tape color value sequentially before reacting to it.\n\n\n\n\n\n\n\n\n\n\nTest Circuit Values (2/20/18)\n\n\nActual Robot Readings (2/27/18)\n\n\nNew Tape Sensor Position (3/2/18)\n\n\nDifferent Lighting (3/3/18)\n\n\n\n\n\n\n\n\n\n\nWhite (no tape)\n\n\n1023 (just above saturation. Measured as 3.34V)\n\n\n880\n\n\n560\n\n\n950\n\n\n\n\n\n\nBlack\n\n\n125\n\n\n95\n\n\n50\n\n\n100\n\n\n\n\n\n\nGrey\n\n\n400\n\n\n310\n\n\n160\n\n\n300\n\n\n\n\n\n\nGreen\n\n\n910\n\n\n480\n\n\n260\n\n\n690\n\n\n\n\n\n\n\n\nTipper Arm\n\n\nAfter checking off the basic functionality of the robot, the team decided that the next highest priority for the robot was developing a tipping mechanism. The reasoning was that against a highly functional opponent, in increasingly later game states it would be difficult to regain control of funding rounds by simply dumping balls. In essence, the tipper is the game changer, we could not imagine robots without that level of functionality prevailing against robots with it. Our initial design ideations centered around dropping a weight on a reel or a servo driven \u201cbow drill\u201d poker that provided linear actuation not unlike fire starters of the paleolithic age. We quickly realized that both these strategies limited the speed of our robot through the funding rounds and we would have to make strategy decision: Do we drop balls and move quickly or do we stop to tip? Additionally, when would we know when to tip and how could we pick up the state of the beacon from the funding round before committing to a robot deceleration. These questions sent us back to the drawing board looking for a better solution.\n\n\nWe thought about quick acting high energy sources for quick funding round tipping. Compressed springs or dynamic linkages could provide faster action but would prove complicated. Another idea occurred which was to use on board compressed air to blast a jet of air against the funding round. It wouldn\u2019t be dangerous and violate the safety guidelines but it would provide a dynamic fast acting tipper that would allow drive by tipping along with ball dropping. We started experimenting with air in a can as even the low pressure delta could still provide a regulated choked flow at a pre-sized converging nozzle for air (k = 1.4 requires a minimum delta P of ~ 2) We quickly realized though that the available volume in these cans was fairly small, and the required mass flux was relatively high. We measured tipping force for the funding rounds around 300g and calculated that we would need a minimum nozzle orifice of .05 inch OD. The issue with this was that in testing 10 L allowed us to get 2-3 tips. Using a high pressure CO2 disposable cartridge we could easily get 10L for $2-3. It would be difficult to get more than 10 L in a hand-pumped air canister which we could feasibly get up to 150 psi. However, to get repeatable tips in a round we wanted more and thus started thinking about using refillable liquid CO2 canisters. We did some quick research and realized that this would not only be a hassle but was definitely outside the available funding range for the robot.\n\n\nThe team went back to the drawing board a second time and came up with the idea of a \u201csnow plow\u201d tipper. This tipper would operate while driving and be able to bounce over the funding rounds applying a tipping impulse and bounce over the wall of the game board if necessary. The first conceptual version was a stiff steel spring mounted between two points that could be brought towards each other thus lowering the plow into tipping position. Through its compliance, it would be able to depress the funding rounds without causing damage to the robot. Finding the right spring material proved a challenge though so we switched to the idea of a weighted swing arm that could be pulled up by a non-backdriveable DC motor. At first the arm did not reach the funding bins so shims and an angled guide were used to get the arm to extend out further.\n\n\nReloading Mechanisms\n\n\nUsing a coordinate drive system allowed us to trigger the reload beacon by driving directly into it. The robot was able to register a reload through limit switches placed as obstructions at the entrance of each tube (switch would be triggered as balls passed through into the tube). In order to load the balls quickly, we fabricated custom ball loaders out of large plunger syringes. The end was modified to have a flap valve that allowed the balls to be pushed through. A fast reloading mechanism allowed the software to wait for a much shorter time before assuming reloading was complete.\n\n\nBeacon Sensing\n\n\nWe decided that the easiest and fastest strategy would be to only read the beacon at the gate, and not have to worry about filtering in hardware (especially since the signals were square waves and not sinusoidal) or checking the frequency in software (would require some wait wait time) to separate and read the different beacon signals. This allowed us to just use an active high-pass filtering circuit (inverting topology) to remove DC interference as well as 60Hz noise from the overhead lights. We initially added a single phototransistor to the input of this filter in a sourcing configuration to sense the LED beacon. However, since each phototransistor has a fairly narrow field of view, we used 4 phototransistors connected in parallel and physically arranged to be facing slightly different angles but at the same height. This allowed us to repeatedly sense the gate beacon despite slight changes in the robot orientation. Since the gate beacon has the highest duty cycle frequency of 4125Hz and the next highest beacon is at 3500Hz, the filter was designed to have a cutoff frequency of \nf_c = \\frac{1}{2\\pi R_1C} = \\frac{1}{2\\pi*470\\Omega*0.1\\mu F} \\approx 3390 Hz\n. The gain was set to \nA = \\frac{-R_2}{R_1} = \\frac{-100k\\Omega}{470\\Omega} = -213 \n.\n\n\nIn order to avoid reading the frequency in software and also to smooth out sudden fluctuations in sensor readings, a 1uF capacitor was added as an integrator to the output of the active filter (which would affect the theoretical gain calculated above). We experimented with smaller capacitor values, but found the time constant was too small to effectively smooth out the duty cycle. The result of this design was that the input to the Teensy would now be a steady value that represented the average of the amplified duty cycle, instead of the duty cycled signal itself. When the beacon was on, this amplified average value would be around 1V whereas it would be close to 0.05V when the beacon was off. This simplified the software\u2019s job to quickly reading an analog value, which it would then compare to some experimentally determined threshold value.\n\n\nBill of Materials\n\n\n\n\n\n\n\n\nQuantity\n\n\nPart Name\n\n\nPart Number\n\n\n\n\n\n\n\n\n\n\n2\n\n\n4\" Omni Wheel\n\n\nVex 276-3525\n\n\n\n\n\n\n2\n\n\n3.25\" Omni Wheel\n\n\nVex 276-2185\n\n\n\n\n\n\n2\n\n\nPlanetary Gear 12 V DC Motor\n\n\nServoCity638278\n\n\n\n\n\n\n2\n\n\n1/4\" Axle Machined\n\n\n\n\n\n\n\n\n2\n\n\nGens Ace 7.2V 3000mAh battery\n\n\n\n\n\n\n\n\n1\n\n\n3ft Chain\n\n\n.25\" pitch\n\n\n\n\n\n\n2\n\n\nChain Connecting Links\n\n\n.25\" pitch\n\n\n\n\n\n\n2\n\n\n16 Tooth Sprockets\n\n\n.25\" pitch\n\n\n\n\n\n\n2\n\n\n23 Tooth Sprockets\n\n\n.25\" pitch\n\n\n\n\n\n\n8\n\n\nBushing, flanged, 1/4\" ID x 1/4\" long\n\n\nMcMaster3746K2\n\n\n\n\n\n\n4\n\n\nCollar, set screw, steel, 1/4\"\n\n\nServoCity 6432K12\n\n\n\n\n\n\n2\n\n\nSolenoid\n\n\nJameco 2202335\n\n\n\n\n\n\n2\n\n\ncastor wheels\n\n\n\n\n\n\n\n\n1\n\n\nLarge threaded rod\n\n\n1/4-20\n\n\n\n\n\n\n2\n\n\nSmall Threaded Rods\n\n\n10-32\n\n\n\n\n\n\n2\n\n\nDuron 18\"x 24\"\n\n\n\n\n\n\n\n\n1\n\n\nmisc. small hardware\n\n\n\n\n\n\n\n\n1\n\n\nDC Motor from free bin\n\n\n\n\n\n\n\n\n1\n\n\nWoodturned Pulley\n\n\n\n\n\n\n\n\n1\n\n\nWelded steel tipping arm\n\n\nStainless Steel\n\n\n\n\n\n\n1\n\n\nMachined Tipping Arm Mount\n\n\n6061 Aluminum\n\n\n\n\n\n\n2\n\n\nMachined PVC tubes\n\n\n1.25\" PVC Tubing\n\n\n\n\n\n\n4\n\n\nZip ties\n\n\n\n\n\n\n\n\n1\n\n\nCotton String\n\n\n\n\n\n\n\n\n1\n\n\n15A Breaker\n\n\n1724R13A\n\n\n\n\n\n\n1\n\n\nTeensy\n\n\nV3.2\n\n\n\n\n\n\n2\n\n\nHalf Proto-Boards\n\n\n\n\n\n\n\n\n1\n\n\nTape Sensor\n\n\nopb704wz\n\n\n\n\n\n\n2\n\n\nL298N motor driver\n\n\n\n\n\n\n\n\n5\n\n\nlimit switches\n\n\njameco 2187905\n\n\n\n\n\n\n50\n\n\nStranded Wires\n\n\nas in schematic\n\n\n\n\n\n\n3\n\n\nCapacitors\n\n\nas in schematic\n\n\n\n\n\n\n5\n\n\nResistors\n\n\nas in schematic\n\n\n\n\n\n\n1\n\n\nOp-Amp\n\n\nLM324N\n\n\n\n\n\n\n4\n\n\nPhototransisotrs\n\n\nLTR-3208E\n\n\n\n\n\n\n\n\n\n\nSoftware\n\n\n\n\nGoals and Philosophy\n\n\nOur software design philosophy was aligned with that for our mechanical and electrical design: Solve known challenges fast, while preserving the flexibility required to quickly address future challenges that arose as details about the game board and our competitors emerged.\n\n\nSince software is a more malleable medium than hardware, we knew we could take valuable architectural risks if we started early. Software also benefits from hierarchical abstractions; finding the right abstractions early would dramatically speed development later.\n\n\nStrategy and Design Decisions\n\n\nThus, code development began early and in parallel with hardware. We built test circuits for each component and wrote quick code to drive them. Then, offline, we\u2019d turn that test code into something robust and modular that would support all the functions we needed of that part of the robot.\n\n\nWe knew early that we would need to have many logical threads of execution running in parallel. As an example, the robot would need to simultaneously: track the north wall, lower its tipper, deposit balls, count grey tape lines, and move left. Each would be driven by interrupts and run very quickly.\n\n\nTraditional threading was the wrong solution, even if Teensy Threads were available. Preemptive multitasking requires sophisticated concurrency control mechanisms and tends to leak state through abstractions.\n\n\nCooperative multitasking was clearly a better and simpler solution. Since we\u2019re running on a single-core system and each routine runs extremely quickly, it would save us from most concurrency-related bugs.  Teensy Fibers didn\u2019t seem to provide the right interface around interrupts, so we settled on building our own interrupt-driven infrastructure.\n\n\nBeginning from the End\n\n\nIt\u2019s easiest to explain the abstractions we chose by starting with the final sketch we wrote. We\u2019ll explain what properties we wanted it to have and then building upwards through the dependency graph of C++ libraries we wrote to support it.\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DriveMotor.hpp\"\n#include \"LaunchTube.hpp\"\n#include \"TapeSensor.hpp\"\n#include \"TipperMotor.hpp\"\n\nstatic LaunchTube upperTube(6, 11, 1); //solenoid pin, switch pin, initial ball count\nstatic LaunchTube lowerTube(7, 12, 3);\n\nstatic DriveMotor xAxisMotor(2, 3, 5, true, 16); //out1 pin, out2 pin, en pin, direction, switch pin\nstatic DriveMotor yAxisMotor(0, 1, 4, false, 15, 17);\n\nstatic TipperMotor tipper(8, 9, 10, false); //out1 pin, out2 pin, en pin, direction\n\nstatic TapeSensor tapeSensor(14, 15000); //phototransistor pin, minimum microsec over a line\nstatic const uint32_t GATE_SENSOR_PIN = 18;\n\nstatic uint32_t startMillis = 0;\n\nstatic int greyCount = 0;\nstatic int greenCount = 0;\n\nvoid setup() {\n  // Init serial object.\n  Serial.begin(0); // Baud rate ignored. Teensy USB is always standard 12 Mbit/sec\n  analogWriteResolution(10); // Real resolution at this frequency.\n  pinMode(GATE_SENSOR_PIN, INPUT);\n  Serial.println(\"Booted\");\n\n  yAxisMotor.notifyOnNextNegativeLimitPress([]() {\n    startMillis = millis();     // Stop play at 2:10\n    primaryPass();\n    Serial.println(\"Started\");\n  });\n}\n\nstatic void primaryPass() {\n  xAxisMotor.timedMove(-1023, 0.4*1000000, []() {\n    yAxisMotor.moveToLimit(400, []() {  //go @ 400 power until we hit wall track switch\n      tipper.down();\n      xAxisMotor.move(-420);\n      yAxisMotor.trackPositiveLimit(400);\n      greyCount = 0;\n      tapeSensor.observeGrey([]() {\n        greyCount++;\n\n        if (greyCount == 1) { //hit first grey line\n          xAxisMotor.timedMove(0, 0.8*1000000, []() {\n            xAxisMotor.move(-340);\n          });\n        } else if (greyCount == 2) { //hit second grey line\n          xAxisMotor.stop();\n          lowerTube.dumpBallsPresent([]() {\n            xAxisMotor.move(-370);\n          });\n        } else if (greyCount == 3) {  //hit third grey line\n          upperTube.dumpBallsPresent([]() {});\n          tapeSensor.stopObserving();\n          thirdGreyToGateAttempt();\n        }\n      });\n    });\n  });\n}\n\nstatic void thirdGreyToGateAttempt() {\n  yAxisMotor.stopTrackingPositiveLimit(); // Stop hugging wall to avoid turning\n  xAxisMotor.timedMove(0, 1.5*1000000, []() {\n    tipper.up();\n    xAxisMotor.move(-400); //not full speed so you don't slam into wall by the gate\n    tapeSensor.observeBlack([]() {  //hit black line in front of gate\n      tapeSensor.stopObserving();\n\n      xAxisMotor.stop();\n\n      if (gateOpen()) {\n        // Sprint until we've won, then slowly drive through to the wall.\n        yAxisMotor.move(1023);\n        greenCount = 0;\n        tapeSensor.observeGreen([]() {\n          greenCount++;\n          if (greenCount == 2) {\n            yAxisMotor.moveToLimit(300, []() {\n              // We've won!\n              disableAll();\n            });\n          }\n        });\n      } else {\n        moveToReload();\n      }\n    });\n  });\n}\n\nstatic void moveToReload() {\n  // Timed sprint toward South wall\n  yAxisMotor.timedMove(-1023, 0.4*1000000, []() {\n    // Finish moving South\n    yAxisMotor.moveToLimit(-500, []() {\n      // Pull away from South wall to reduce friction\n      yAxisMotor.timedMove(400, 0.6*1000000, [](){});\n\n      // Timed sprint toward East wall\n      xAxisMotor.timedMove(1023, 3.1*1000000, [](){ //~3.5\n        // Finish moving East and stay there\n        xAxisMotor.moveToLimit(500, []() {\n          xAxisMotor.timedMove(1023, 0.05*1000000, [](){}); // back off just a bit\n\n          // Go up and hit the button.\n          yAxisMotor.trackPositiveLimit(600);\n          // wait for reload, then continue\n          lowerTube.notifyOnNextLoad([](){\n            yAxisMotor.stopTrackingPositiveLimit();\n            xAxisMotor.stopTrackingPositiveLimit();\n            secondaryPass();\n          });\n        });\n      });\n    });\n  });\n}\n\nstatic void secondaryPass() {\n  // Reset against round wall\n  yAxisMotor.timedMove(-400, 0.3*1000000, [](){});\n  xAxisMotor.timedMove(-1023, 1.0*1000000, [](){\n    yAxisMotor.moveToLimit(400, [](){\n      tipper.down();\n      yAxisMotor.trackPositiveLimit(400);\n      xAxisMotor.move(-1023);\n\n      greyCount = 0;\n      tapeSensor.observeGrey([]() {\n        greyCount++;\n\n        if (greyCount == 1) { //hit first grey line\n          xAxisMotor.timedMove(0, 0.8*1000000, []() {\n            xAxisMotor.move(-340);\n          });\n        } else if (greyCount == 2) { //hit second grey line\n          xAxisMotor.stop();\n          lowerTube.dumpBallsPresent([]() {\n            xAxisMotor.move(upperTube.hasBalls() ? -370 : -1023);\n          });\n        } else if (greyCount == 3) {  //hit third grey line\n          if (upperTube.hasBalls()) {\n            upperTube.dumpBallsPresent([]() {\n              tapeSensor.stopObserving();\n              thirdGreyToGateAttempt();\n            });\n          } else {\n            tapeSensor.stopObserving();\n            thirdGreyToGateAttempt();\n          }\n        }\n      });\n    });\n  });\n}\n\nstatic bool gateOpen() {\n  Serial.print(\"Gate says: \"); Serial.println(analogRead(GATE_SENSOR_PIN));\n  // return false;\n  return analogRead(GATE_SENSOR_PIN) \n 15;\n}\n\nstatic void disableAll() {\n   Serial.println(\"Disabled\");\n   upperTube.disable();\n   lowerTube.disable();\n   tapeSensor.stopObserving();\n   xAxisMotor.disable();\n   yAxisMotor.disable();\n   tipper.disable();\n}\n\nvoid loop() {\n  if (startMillis != 0 \n millis() \n startMillis + (2*60 + 10) * 1000) {\n    disableAll();\n    startMillis = 0;\n  }\n  Serial.println(\"*\"); delay(500);\n}\n\n\n\nBlocking code would have been extremely problematic given the concurrent and interrupt-driven requirements of the program. But you\u2019ll notice that the program reads (and writes!) almost as easily as blocking code would. You declare sequentially all the things you want to happen at the same time\u2014since the processor operates so fast compared to physical world time\u2014and declare the things you want to happen when the operation completes inside of completion handler. If you\u2019ve ever programmed for iOS, Grand Central Dispatch is somewhat similar. The callbacks are handled as C++11 lambdas, which turn code into a callable object with associated data.\n\n\nFurther, at the top level, everything is semantic. You declare what you want done\u2014move in the positive x direction for z seconds\u2014and the implementation is handled by the libraries.\n\n\nOur libraries for controlling are as follows:\n\n\n\n\nTapeSensor\n: Manages de-noising tape crossings and notifying the main program\n\n\nDriveMotor\n: Controls a motor and its interaction with the limit switches tracking its position. Two instances, one for each coordinate axis.\n\n\nLaunchTube\n: Manages launching balls, counting the number of balls loaded, and notifying the main program on reload. Two instances, one for each physical tube.\n\n\nTipperMotor\n: Manages raising and lowering the tipper arm asynchronously.\n\n\n\n\nThey\u2019re supported by the following abstractions around timers and interrupts:\n\n\n\n\nLambdaInterrupt\n: Modifies interrupts on digital pins to dispatch to lambdas instead of function pointers, as in Arduino\u2019s implementation.\n\n\nDebouncedInterrupt\n: A version of the above that has a maximum firing frequency, easily adjustable in software.\n\n\nLambdaTimer\n: IntervalTimer modified to call lambdas. Dynamically allocates itself onto one of the 4 hardware timers.\n\n\nDispatchAfter\n: Uses a LambdaTimer to call you back once after a certain interval has elapsed. Then deallocated the timer.\n\n\nMissingSystemFunctions\n: Fools the C++ standard libraries to link by faking like we\u2019re running on an OS.\n\n\n\n\nYou\u2019ll also see some other code in the main sketch. We implemented gate sensing directly in there because it was so few lines that it didn\u2019t merit an abstraction boundary. When interrupts aren\u2019t driving the code, the main loop prints out asterisks as a heartbeat to let us know that the program is still running. Without a debugger, that\u2019s the only easy way to know if our function-pointer shenanigans had crashed the program. Finally you\u2019ll notice that we implemented the kill timer by polling. We don\u2019t like it either, but it\u2019s too long for the hardware timers, and it\u2019s just using up whatever spare processing power isn\u2019t consumed by the interrupts.\n\n\nInfrastructure\n\n\nIn order to understand how the higher level abstractions work, we first have to talk through the lower level ones.\n\n\nLambdaInterrupt\n\n\nThe first obstacle is that Arduino\u2019s interrupt handling makes building object-oriented abstractions on top of it impossible. Since it only calls back function pointers, it can\u2019t associate data with the calls. That means it can\u2019t call back an instance of a class, which means you can\u2019t wrap logic you want to instantiate multiple off in a class. This is really bad.\n\n\nHere\u2019s a solution, where we wrap Arduino\u2019s interrupt dispatch to make it call lambdas.\n\n\nThe syntax is a little obtuse, but basically we\u2019re just making a giant bank of functions that we always point the interrupts to. These functions just route the call to out std::function from a lookup table.\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#pragma once\n\n#include \nfunctional\n\n\n// Wrapper of Teensy Interrupts to support binding state with c++11 lambdas.\n// You need this functionality to be able to wrap interrupt calls inide of a class.\n// (You'll be much happier using this interface than looking at the implementation)\n\nnamespace LambdaInterrupt {\n        // Assumes you've already set the pinmode\n        void attach(uint8_t pin, uint8_t event_type, std::function\nvoid()\n callback);\n        void detatch(uint8_t pin);\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LambdaInterrupt.hpp\"\n\n#include \nArduino.h\n\n\n// General stratedy: Define a fixed size block of functions, one per pin.\n// Those functions just dispatch the incoming call to the requested callback.\n\nnamespace LambdaInterrupt {\n\n        static std::function\nvoid()\n callbacks[24]; // From user\n\n// Begin: Dispatch table code\n#define DISPATCH_FN_FACTORY(n) static void _isr_dispatch_##n() { callbacks[n](); }\n        DISPATCH_FN_FACTORY(0) DISPATCH_FN_FACTORY(1) DISPATCH_FN_FACTORY(2)\n        DISPATCH_FN_FACTORY(3) DISPATCH_FN_FACTORY(4) DISPATCH_FN_FACTORY(5)\n        DISPATCH_FN_FACTORY(6) DISPATCH_FN_FACTORY(7) DISPATCH_FN_FACTORY(8)\n        DISPATCH_FN_FACTORY(9) DISPATCH_FN_FACTORY(10) DISPATCH_FN_FACTORY(11)\n        DISPATCH_FN_FACTORY(12) DISPATCH_FN_FACTORY(13) DISPATCH_FN_FACTORY(14)\n        DISPATCH_FN_FACTORY(15) DISPATCH_FN_FACTORY(16) DISPATCH_FN_FACTORY(17)\n        DISPATCH_FN_FACTORY(18) DISPATCH_FN_FACTORY(19) DISPATCH_FN_FACTORY(20)\n        DISPATCH_FN_FACTORY(21) DISPATCH_FN_FACTORY(22) DISPATCH_FN_FACTORY(23)\n#undef DISPATCH_FN_FACTORY\n\n        static void (*isr_dispatch_table[])() = {\n                _isr_dispatch_0, _isr_dispatch_1, _isr_dispatch_2,\n                _isr_dispatch_3, _isr_dispatch_4, _isr_dispatch_5,\n                _isr_dispatch_6, _isr_dispatch_7, _isr_dispatch_8,\n                _isr_dispatch_9, _isr_dispatch_10, _isr_dispatch_11,\n                _isr_dispatch_12, _isr_dispatch_13, _isr_dispatch_14,\n                _isr_dispatch_15, _isr_dispatch_16, _isr_dispatch_17,\n                _isr_dispatch_18, _isr_dispatch_19, _isr_dispatch_20,\n                _isr_dispatch_21, _isr_dispatch_22, _isr_dispatch_23\n        };\n// End: Dispatch table code\n\n        void attach(uint8_t pin, uint8_t event_type, std::function\nvoid()\n callback) {\n                callbacks[pin] = callback;\n                attachInterrupt(digitalPinToInterrupt(pin), isr_dispatch_table[pin], event_type);\n        }\n\n        void detatch(uint8_t pin) {\n                detachInterrupt(digitalPinToInterrupt(pin));\n        }\n};\n\n\n\nDebouncedInterrupt\n\n\nWe\u2019ll then wrap the above to have a maximum firing frequency, easily adjustable in software. This increases our development speed, because it saves having to build filters and hysteresis circuits.\n\n\nIt works by storing the last call time and suppressing callbacks that occur too quickly after the first one.\n\n\nWe wrote this class primarily for counting balls going into the launch tubes.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DispatchAfter.hpp\"\n\nclass DebouncedInterrupt {\npublic:\n        // Usage example for an even that could happen at most 4 times a second:\n        // DebouncedInterrupt(10, INPUT_PULLUP, FALLING, 250000 /*us*/, [this]() {\n        //         // Respond to event.\n        // });\n        DebouncedInterrupt(uint8_t pin, uint8_t pinmode, uint8_t event_type, uint32_t min_period /*us*/, std::function\nvoid()\n callback);\n        ~DebouncedInterrupt();\n\n        // For detecting after a debounced burst has finished.\n        void dispatchAfterBurstFinish(uint32_t max_time_between_triggers, std::function\nvoid()\n callback);\n\n        // Stops you getting callbacks on this pin.\n        void disable();\n\nprivate:\n        DispatchAfter burst_finish;\n        std::function\nvoid()\n burst_callback;\n        uint32_t max_time_between_triggers;\n\n        const uint8_t pin;\n        const std::function\nvoid()\n callback;\n        const uint32_t min_period;\n        uint32_t last_fire;\n        bool active;\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"DebouncedInterrupt.hpp\"\n\n#include \"LambdaInterrupt.hpp\"\n\n#include \nArduino.h\n\n\n\nDebouncedInterrupt::DebouncedInterrupt(uint8_t pin, uint8_t pinmode, uint8_t event_type, uint32_t min_period, std::function\nvoid()\n callback) :\n        pin(pin),\n        callback(callback),\n        min_period(min_period),\n        last_fire(0),\n        active(true)\n{\n        pinMode(pin, pinmode);\n        LambdaInterrupt::attach(pin, event_type, [this]() {\n                uint32_t curr_time = micros();\n                if (curr_time - last_fire \n= this-\nmin_period) {\n                        last_fire = curr_time;\n                        if (burst_callback) {\n                                // schedules for the first time or reschedules into the future\n                                burst_finish.schedule(max_time_between_triggers, [this]() {\n                                        burst_callback();\n                                        burst_callback = [](){};\n                                });\n                        }\n                        this-\ncallback();\n                }\n        });\n}\n\nDebouncedInterrupt::~DebouncedInterrupt() {\n        disable();\n}\n\nvoid DebouncedInterrupt::dispatchAfterBurstFinish(uint32_t max_time_between_triggers, std::function\nvoid()\n callback) {\n        this-\nmax_time_between_triggers = max_time_between_triggers;\n        this-\nburst_callback = callback;\n}\n\nvoid DebouncedInterrupt::disable() {\n        if (active) {\n                burst_finish.cancel();\n                LambdaInterrupt::detatch(pin);\n                active = false;\n        }\n}\n\n\n\nLambdaTimer\n\n\nFor the same reasons we needed to modify attachInterrupt, we need to change IntervalTimer modified to call lambdas. Here\u2019s a modified version of IntervalTimer. As with the original, it dynamically allocates itself onto one of the 4 hardware timers.\n\n\nThe trickiness in the code is in not deallocating lambdas while they\u2019re running. A naive implementation would delete running lambdas if they descheduled themselves while running\u2014especially if they reallocated another lambda in their place. This leads to really nasty bugs. Instead, we defer deallocation of internal resources until after the lambda call has ended.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n// Modernized by Christopher Sauer on 2/24/2018 to take lambdas instead of fnptrs\n\n/* Teensyduino Core Library\n * http://www.pjrc.com/teensy/\n * Copyright (c) 2017 PJRC.COM, LLC.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * 1. The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * 2. If the Software is incorporated into a build system that allows\n * selection among a list of target devices, then similar target\n * devices manufactured by PJRC.COM must be included in the list of\n * target devices and selectable in the same manner.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"kinetis.h\"\n\n#include \nfunctional\n\n\nclass LambdaTimer {\nprivate:\n        static const uint32_t MAX_PERIOD = UINT32_MAX / (F_BUS / 1000000.0);\npublic:\n        LambdaTimer();\n        ~LambdaTimer();\n\n        bool active();\n\n        bool begin(uint32_t microseconds, std::function\nvoid()\n callback);\n        void update(uint32_t microseconds);\n\n        void end();\n        void priority(uint8_t n);\n        operator IRQ_NUMBER_t();\n\nprivate:\n        friend void pit_isr();\n        friend void pit0_isr();\n        friend void pit1_isr();\n        friend void pit2_isr();\n        friend void pit3_isr();\n        void deallocResources();\n\n        KINETISK_PIT_CHANNEL_t *channel;\n        uint8_t nvic_priority;\n        #if defined(KINETISL)\n        static uint8_t nvic_priorites[2];\n        #endif\n        bool beginCycles(uint32_t cycles, std::function\nvoid()\n callback);\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n// Modernized by Christopher Sauer on 2/24/2018 to take lambdas instead of fnptrs\n\n/* Teensyduino Core Library\n * http://www.pjrc.com/teensy/\n * Copyright (c) 2017 PJRC.COM, LLC.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * 1. The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * 2. If the Software is incorporated into a build system that allows\n * selection among a list of target devices, then similar target\n * devices manufactured by PJRC.COM must be included in the list of\n * target devices and selectable in the same manner.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"LambdaTimer.hpp\"\n\n#include \nArduino.h\n\n\n#if defined(KINETISK)\n#define NUM_CHANNELS 4\n\n#elif defined(KINETISL)\n#define NUM_CHANNELS 2\nuint8_t LambdaTimer::nvic_priorites[2] = {255, 255};\n#endif\n\nstatic std::function\nvoid()\n funct_table[NUM_CHANNELS];\nstatic LambdaTimer* dealloc_on_exit[NUM_CHANNELS] = {nullptr};\n\nLambdaTimer::LambdaTimer() {\n        channel = nullptr;\n        nvic_priority = 128;\n}\n\nLambdaTimer::~LambdaTimer() {\n        deallocResources();\n}\n\nbool LambdaTimer::active() {\n        const int index = channel - KINETISK_PIT_CHANNELS;\n        return channel != nullptr \n dealloc_on_exit[index] == false;\n}\n\nbool LambdaTimer::begin(uint32_t microseconds, std::function\nvoid()\n callback) {\n        if (microseconds == 0 || microseconds \n MAX_PERIOD)\n                return false;\n        uint32_t cycles = (F_BUS / 1000000) * microseconds - 1;\n        if (cycles \n 36) return false;\n        return beginCycles(cycles, callback);\n}\n\nvoid LambdaTimer::update(uint32_t microseconds) {\n        if (microseconds == 0 || microseconds \n MAX_PERIOD) return;\n        uint32_t cycles = (F_BUS / 1000000) * microseconds - 1;\n        if (cycles \n 36) return;\n        if (channel) channel-\nLDVAL = cycles;\n}\n\nbool LambdaTimer::beginCycles(uint32_t cycles, std::function\nvoid()\n callback)\n{\n        if (channel) {\n                channel-\nTCTRL = 0;\n                channel-\nTFLG = 1;\n        } else {\n                SIM_SCGC6 |= SIM_SCGC6_PIT;\n                __asm__ volatile(\"nop\"); // solves timing problem on Teensy 3.5\n                PIT_MCR = 1;\n                channel = KINETISK_PIT_CHANNELS;\n                while (1) {\n                        if (channel-\nTCTRL == 0) break;\n                        if (++channel \n= KINETISK_PIT_CHANNELS + NUM_CHANNELS) {\n                                Serial.println(\"Out of timers\");\n                                channel = nullptr;\n                                return false;\n                        }\n                }\n        }\n        int index = channel - KINETISK_PIT_CHANNELS;\n        dealloc_on_exit[index] = nullptr;\n        funct_table[index] = callback;\n        channel-\nLDVAL = cycles;\n        channel-\nTCTRL = 3;\n#if defined(KINETISK)\n        NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);\n        NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);\n#elif defined(KINETISL)\n        nvic_priorites[index] = nvic_priority;\n        if (nvic_priorites[0] \n= nvic_priorites[1]) {\n                NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);\n        } else {\n                NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);\n        }\n        NVIC_ENABLE_IRQ(IRQ_PIT);\n#endif\n        Serial.print(\"Allocating timer\"); Serial.println(index);\n        return true;\n}\n\nvoid LambdaTimer::end() {\n        if (channel) {\n                const int index = channel - KINETISK_PIT_CHANNELS;\n                dealloc_on_exit[index] = this;\n        }\n}\n\nvoid LambdaTimer::deallocResources() {\n        if (channel) {\n                int index = channel - KINETISK_PIT_CHANNELS;\n                Serial.print(\"Deallocating timer\"); Serial.println(index);\n#if defined(KINETISK)\n                NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);\n#elif defined(KINETISL)\n                // TODO: disable IRQ_PIT, but only if both instances ended\n#endif\n                funct_table[index] = std::function\nvoid()\n();\n                channel-\nTCTRL = 0;\n#if defined(KINETISL)\n                nvic_priorites[index] = 255;\n                if (nvic_priorites[0] \n= nvic_priorites[1]) {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);\n                } else {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);\n                }\n#endif\n                channel = nullptr;\n        }\n}\n\nvoid LambdaTimer::priority(uint8_t n) {\n        nvic_priority = n;\n        #if defined(KINETISK)\n        if (channel) {\n                int index = channel - KINETISK_PIT_CHANNELS;\n                NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);\n        }\n        #elif defined(KINETISL)\n        if (channel) {\n                int index = channel - KINETISK_PIT_CHANNELS;\n                nvic_priorites[index] = nvic_priority;\n                if (nvic_priorites[0] \n= nvic_priorites[1]) {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);\n                } else {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);\n                }\n        }\n        #endif\n}\n\nLambdaTimer::operator IRQ_NUMBER_t() {\n        if (channel) {\n                #if defined(KINETISK)\n                int index = channel - KINETISK_PIT_CHANNELS;\n                return (IRQ_NUMBER_t)(IRQ_PIT_CH0 + index);\n                #elif defined(KINETISL)\n                return IRQ_PIT;\n                #endif\n        }\n        return (IRQ_NUMBER_t)NVIC_NUM_INTERRUPTS;\n}\n\n#if defined(KINETISK)\nvoid pit0_isr()\n{\n        PIT_TFLG0 = 1;\n        if (funct_table[0] \n !dealloc_on_exit[0])\n                funct_table[0]();\n        if (dealloc_on_exit[0]) {\n                dealloc_on_exit[0]-\ndeallocResources();\n                dealloc_on_exit[0] = nullptr;\n        }\n}\n\nvoid pit1_isr() {\n        PIT_TFLG1 = 1;\n        if (funct_table[1] \n !dealloc_on_exit[1])\n                funct_table[1]();\n        if (dealloc_on_exit[1]) {\n                dealloc_on_exit[1]-\ndeallocResources();\n                dealloc_on_exit[1] = nullptr;\n        }\n}\n\nvoid pit2_isr() {\n        PIT_TFLG2 = 1;\n        if (funct_table[2] \n !dealloc_on_exit[2])\n                funct_table[2]();\n        if (dealloc_on_exit[2]) {\n                dealloc_on_exit[2]-\ndeallocResources();\n                dealloc_on_exit[2] = nullptr;\n        }\n}\n\nvoid pit3_isr() {\n        PIT_TFLG3 = 1;\n        if (funct_table[3] \n !dealloc_on_exit[3])\n                funct_table[3]();\n        if (dealloc_on_exit[3]) {\n                dealloc_on_exit[3]-\ndeallocResources();\n                dealloc_on_exit[3] = nullptr;\n        }\n}\n\n#elif defined(KINETISL)\nvoid pit_isr() {\n        if (PIT_TFLG0) {\n                PIT_TFLG0 = 1;\n                if (funct_table[0])\n                        funct_table[0]();\n        }\n        if (PIT_TFLG1) {\n                PIT_TFLG1 = 1;\n                if (funct_table[1])\n                        funct_table[1]();\n        }\n}\n#endif\n\n\n\nDispatchAfter\n\n\nThis is a wrapper around a LambdaTimer that calls you back once after a certain interval has elapsed and hen deallocated the timer. It\u2019s simple code, but saves having to do manual deallocation over and over.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LambdaTimer.hpp\"\n\nclass DispatchAfter{\npublic:\n        void schedule(uint32_t microseconds, std::function\nvoid()\n callback);\n\n        void cancel();\nprivate:\n        LambdaTimer timer;\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"DispatchAfter.hpp\"\n\n#include \nArduino.h\n\n\n\nvoid DispatchAfter::schedule(uint32_t microseconds, std::function\nvoid()\n callback) {\n        bool success = timer.begin(microseconds, [this, callback]() {\n                callback();\n            timer.end();\n        });\n        if (!success) {\n                Serial.println(\"Timer Failed.\");\n        }\n}\n\nvoid DispatchAfter::cancel() {\n        timer.end();\n}\n\n\n\nMissingSystemFunctions\n\n\nThe C++ standard libraries are designed to run on an OS. We can\u2019t get our program to link unless we have some basic functions those libraries assume. This code fakes like our bare metal code running on an OS.\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \nArduino.h\n\n\n// Add in stdlib's missing dependencies.\n// These functions are thing's the code would expect on an OS, but we're\n// running bare metal.\n\nextern \"C\" { // no name mangling\n\n        // No processes, so no killing...\n        int _kill(int pid, int sig) {\n                Serial.printf(\"Process %d sent signal %d.\", pid, sig);\n                return -1; // Error, since we can't kill.\n        }\n\n        // There is only one process...with ID 1!\n        int _getpid() {\n                return 1;\n        }\n\n        // Ah...life without a file system.\n        int _write() {\n                return -1;\n        }\n}\n\n\n\nHardware Libraries\n\n\nWith all that infrastructure built, it\u2019s much easier to build clean abstractions for each hardware subsystem of our robot. Here are the implementations:\n\n\nTapeSensor\n\n\nThis class manages notifying the main program of when various colors of tape are crossed. It also manages (and hides) de-noising crossings of things like cracks and skid marks that mar the course. It does so via an easily adjustable tight upper bound on the time taken to cross a tape line.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LambdaTimer.hpp\"\n\nclass TapeSensor {\npublic:\n        TapeSensor(uint8_t analog_input_pin, uint32_t min_crossing_duration);\n\n        void observeBlack(std::function\nvoid()\n on_black);\n        void observeGrey(std::function\nvoid()\n on_grey);\n        void observeGreen(std::function\nvoid()\n on_green);\n\n        void stopObserving();\n\nprivate:\n        void startTimerIfNeeded();\n\n        enum class Tape { UNKNOWN, WHITE, BLACK, GREY, GREEN };\n        Tape last_seen, last_last_seen;\n\n        const uint8_t analog_input_pin;\n        const uint32_t timer_duration;\n\n        LambdaTimer sensor_poll_timer;\n        std::function\nvoid()\n on_black;\n        std::function\nvoid()\n on_grey;\n        std::function\nvoid()\n on_green;\n        bool black_active, grey_active, green_active;\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"TapeSensor.hpp\"\n\n#include \nArduino.h\n\n\n\nTapeSensor::TapeSensor(uint8_t analog_input_pin, uint32_t min_crossing_duration) :\nlast_seen(Tape::UNKNOWN),\nlast_last_seen(Tape::UNKNOWN),\nanalog_input_pin(analog_input_pin),\ntimer_duration(min_crossing_duration/2), // So we're guaranteed to get 2 samples on it.\nblack_active(false), grey_active(false), green_active(false)\n{\n        pinMode(analog_input_pin, INPUT);\n}\n\nvoid TapeSensor::observeBlack(std::function\nvoid()\n on_black) {\n        this-\non_black = on_black;\n        black_active = true;\n        startTimerIfNeeded();\n}\n\nvoid TapeSensor::observeGrey(std::function\nvoid()\n on_grey) {\n        this-\non_grey = on_grey;\n        grey_active = true;\n        startTimerIfNeeded();\n}\n\nvoid TapeSensor::observeGreen(std::function\nvoid()\n on_green) {\n        this-\non_green = on_green;\n        green_active = true;\n        startTimerIfNeeded();\n}\n\nvoid TapeSensor::stopObserving() {\n        sensor_poll_timer.end();\n        last_seen = Tape::UNKNOWN;\n        last_last_seen = Tape::UNKNOWN;\n\n        black_active = grey_active = green_active = false;\n}\n\nvoid TapeSensor::startTimerIfNeeded() {\n        if (!sensor_poll_timer.active()) {\n                sensor_poll_timer.begin(timer_duration, [this] {\n                        static const uint16_t WHITE_GREEN_THRESH = 825;\n                        static const uint16_t GREEN_GREY_THRESH = 500; //below crack thresh\n                        static const uint16_t GREY_BLACK_THRESH = 200;\n\n                        uint16_t reading = analogRead(analog_input_pin);\n                    // Serial.print(reading); Serial.print(\"\\t\"); Serial.println(black_active);\n\n                        Tape seen = Tape::WHITE;\n                        if (reading \n GREY_BLACK_THRESH) {\n                                seen = Tape::BLACK;\n                        } else if (reading \n GREEN_GREY_THRESH) {\n                                seen = Tape::GREY;\n                        } else if (reading \n WHITE_GREEN_THRESH) {\n                                seen = Tape::GREEN;\n                        }\n\n                        if (last_last_seen != last_seen \n last_seen == seen) {\n                                if (seen == Tape::BLACK \n black_active) {\n                                        on_black();\n                                        Serial.println(\"Seen black\");\n                                } else if (seen == Tape::GREY \n grey_active) {\n                                        on_grey();\n                                        Serial.println(\"Seen grey\");\n                                } else if (seen == Tape::GREEN \n green_active) {\n                                        on_green();\n                                        Serial.println(\"Seen green\");\n                                }\n                        }\n\n                        last_last_seen = last_seen;\n                        last_seen = seen;\n                });\n        }\n}\n\n\n\nDriveMotor\n\n\nThis class controls a motor and its interaction with the limit switches tracking its position. It provides a lot of the tracking and stopping primitives that make the main code so simple.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DispatchAfter.hpp\"\n\n// Limit switch is considered the positive direction of motion.\n// Set polarity to make that so.\n\nclass DriveMotor {\npublic:\n        DriveMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity, uint8_t limit_switch_pin, uint8_t negative_limit_switch_pin = -1);\n\n        void timedMove(int directional_speed, uint32_t duration_micros, std::function\nvoid()\n completionHandler);\n        void moveToLimit(int speed, std::function\nvoid()\n completionHandler);\n\n        void trackPositiveLimit(int speed);\n        void stopTrackingPositiveLimit();\n\n        void notifyOnNextNegativeLimitPress(std::function\nvoid()\n pressed);\n\n        void move(int directional_speed);\n        void stop();\n\n        // Call me on 2:10 timer expiring.\n        void disable();\n\nprivate:\n        bool enabled;\n\n        const uint8_t bridge_pin_1;\n        const uint8_t bridge_pin_2;\n        const uint8_t enable_pin_pwm;\n        const bool polarity;\n        const uint8_t limit_switch_pin;\n        const uint8_t negative_limit_switch_pin;\n\n        DispatchAfter stop_dispatch;\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DriveMotor.hpp\"\n#include \"LambdaInterrupt.hpp\"\n\n#include \nArduino.h\n\n\n\nDriveMotor::DriveMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity, uint8_t limit_switch_pin, uint8_t negative_limit_switch_pin) :\nenabled(true),\nbridge_pin_1(bridge_pin_1),\nbridge_pin_2(bridge_pin_2),\nenable_pin_pwm(enable_pin_pwm),\npolarity(polarity),\nlimit_switch_pin(limit_switch_pin),\nnegative_limit_switch_pin(negative_limit_switch_pin)\n{\n        pinMode(bridge_pin_1, OUTPUT);\n        pinMode(bridge_pin_2, OUTPUT);\n        pinMode(enable_pin_pwm, OUTPUT);\n        stop();\n        pinMode(limit_switch_pin, INPUT_PULLUP);\n        if (negative_limit_switch_pin \n= 0)\n                pinMode(negative_limit_switch_pin, INPUT_PULLUP);\n}\n\nvoid DriveMotor::timedMove(int directional_speed, uint32_t duration_micros, std::function\nvoid()\n completionHandler) {\n        move(directional_speed);\n        stop_dispatch.schedule(duration_micros, [this, completionHandler]() {\n                stop();\n                completionHandler();\n        });\n}\n\nvoid DriveMotor::notifyOnNextNegativeLimitPress(std::function\nvoid()\n pressed) {\n        LambdaInterrupt::attach(negative_limit_switch_pin, FALLING, [this, pressed] () {\n                LambdaInterrupt::detatch(negative_limit_switch_pin);\n                pressed();\n        });\n}\n\nvoid DriveMotor::moveToLimit(int speed, std::function\nvoid()\n completionHandler) {\n        uint8_t limit_pin = limit_switch_pin;\n\n        if (speed \n 0) {\n                if (negative_limit_switch_pin \n 0) {\n                        Serial.println(\"Attempt to use negative limit without a negative limit switch configured.\");\n                        completionHandler();\n                        return;\n                }\n\n                limit_pin = negative_limit_switch_pin;\n        }\n\n        if (digitalRead(limit_pin) == LOW) {\n                completionHandler();\n        } else {\n                move(speed);\n                LambdaInterrupt::attach(limit_pin, FALLING, [this, completionHandler, limit_pin] () {\n                        LambdaInterrupt::detatch(limit_pin);\n                        stop();\n                        completionHandler();\n                });\n        }\n}\n\nvoid DriveMotor::trackPositiveLimit(int speed) {\n        if (speed \n 0)\n                speed = -speed;\n\n        move(speed);\n        LambdaInterrupt::attach(limit_switch_pin, CHANGE, [this, speed] () {\n                if (digitalRead(limit_switch_pin) == HIGH) {\n                        move(speed);\n                } else {\n                        stop();\n                }\n        });\n}\n\nvoid DriveMotor::stopTrackingPositiveLimit() {\n        stop();\n        LambdaInterrupt::detatch(limit_switch_pin);\n}\n\nvoid DriveMotor::disable() {\n        stopTrackingPositiveLimit();\n        stop_dispatch.cancel();\n        stop();\n        enabled = false;\n}\n\nvoid DriveMotor::move(int directional_speed) {\n        if (!enabled) return;\n\n        if (polarity)\n                directional_speed = -directional_speed;\n\n        if (directional_speed \n 0) {\n                digitalWrite(bridge_pin_1, HIGH);\n                digitalWrite(bridge_pin_2, LOW);\n        } else {\n                digitalWrite(bridge_pin_1, LOW);\n                digitalWrite(bridge_pin_2, HIGH);\n                directional_speed = -directional_speed; //abs\n        }\n\n        analogWrite(enable_pin_pwm, directional_speed);\n}\n\nvoid DriveMotor::stop() {\n        analogWrite(enable_pin_pwm, 0);\n}\n\n\n\nLaunchTube\n\n\nThis class manages launching balls, counting the number of balls loaded, and notifying the main program on reload. We instantiate it twice, one for each physical tube.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DebouncedInterrupt.hpp\"\n#include \"DispatchAfter.hpp\"\n\n// Handles all the work associated with managing a launch tube.\n// (debouncing, initialization, resetting solenoids, etc.)\n// Just sit back and enjoy the interface.\n\n// Note: Class assumes it will not be destructed for the lifetime of the program.\n\nclass LaunchTube {\npublic:\n        LaunchTube(uint8_t solenoid_pin, uint8_t limit_switch_pin, uint8_t starting_balls);\n\n        void dumpBallsPresent(std::function\nvoid()\n completionHandler);\n        void dumpOneBallPresent(std::function\nvoid()\n completionHandler);\n\n        void notifyOnNextLoad(std::function\nvoid()\n loaded);\n\n        bool hasBalls();\n\n        // Call me on timer expiring.\n        void disable();\n\nprivate:\n        void dumpNBallsPresent(int nBalls, std::function\nvoid()\n completionHandler);\n        void solenoidIn();\n        void solenoidOut();\n\n        bool enabled;\n        DispatchAfter solenoid_shutoff;\n        const uint8_t solenoid_pin;\n        int num_balls;\n        DebouncedInterrupt limit_switch_notifier;\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LaunchTube.hpp\"\n\n#include \nArduino.h\n\n\nstatic int calcDispenseTime(int numBalls) {\n  static const int INTERCEPT = 80000; // Add some safety margin\n  static const int SLOPE = 50000;\n  return SLOPE*numBalls + INTERCEPT;\n}\n\n\nLaunchTube::LaunchTube(uint8_t solenoid_pin, uint8_t limit_switch_pin, uint8_t starting_balls) :\n        enabled(true),\n        solenoid_pin(solenoid_pin),\n        num_balls(starting_balls),\n        limit_switch_notifier(limit_switch_pin, INPUT_PULLUP, FALLING, 60000 /*us*/, [this]() {\n                num_balls++;\n        })\n{\n        pinMode(solenoid_pin, OUTPUT);\n        solenoidOut();\n}\n\nvoid LaunchTube::dumpNBallsPresent(int nBalls, std::function\nvoid()\n completionHandler) {\n        if (!enabled) return;\n\n        if (num_balls == 0){\n                completionHandler();\n        } else {\n                solenoidIn();\n                solenoid_shutoff.schedule(calcDispenseTime(nBalls), [this, completionHandler]() {\n                        solenoidOut();\n                        completionHandler();\n                });\n            num_balls -= nBalls;\n        }\n}\n\nvoid LaunchTube::dumpBallsPresent(std::function\nvoid()\n completionHandler) {\n        dumpNBallsPresent(num_balls, completionHandler);\n}\n\nvoid LaunchTube::dumpOneBallPresent(std::function\nvoid()\n completionHandler) {\n        dumpNBallsPresent(1, completionHandler);\n}\n\nvoid LaunchTube::notifyOnNextLoad(std::function\nvoid()\n loaded) {\n        limit_switch_notifier.dispatchAfterBurstFinish(0.3*1000000, loaded);\n}\n\nbool LaunchTube::hasBalls() {\n        return num_balls \n 0;\n}\n\nvoid LaunchTube::disable() {\n        limit_switch_notifier.disable();\n        enabled = false;\n        // Solenoids will get automatically relaxed as time expires.\n        // That way the robot will cease all action at the timer\n        // including stopping, except as to save power.\n}\n\nvoid LaunchTube::solenoidIn() {\n        digitalWrite(solenoid_pin, HIGH);\n}\n\nvoid LaunchTube::solenoidOut() {\n        digitalWrite(solenoid_pin, LOW);\n}\n\n\n\nTipperMotor\n\n\nThis class manages raising and lowering the tipper arm asynchronously, which we do with a simple timer and stall. There\u2019s a double timer backing off raising the tipper so the spring force doesn't cause the tipper to bounce back away from the top limit.\n\n\n#pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DispatchAfter.hpp\"\n\nclass TipperMotor {\npublic:\n        TipperMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity);\n\n        void up();\n        void down();\n\n        // Call me on 2:10 timer expiring.\n        void disable();\n\nprivate:\n        void move(int directional_speed);\n        void stop();\n\n        bool enabled;\n\n        const uint8_t bridge_pin_1;\n        const uint8_t bridge_pin_2;\n        const uint8_t enable_pin_pwm;\n        const bool polarity;\n\n        DispatchAfter stop_dispatch, hold_dispatch;\n};\n\n\n\n\n\n\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\\n  / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"TipperMotor.hpp\"\n\n#include \nArduino.h\n\n\n\nTipperMotor::TipperMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity) :\nbridge_pin_1(bridge_pin_1),\nbridge_pin_2(bridge_pin_2),\nenable_pin_pwm(enable_pin_pwm),\npolarity(polarity)\n{\n        pinMode(bridge_pin_1, OUTPUT);\n        pinMode(bridge_pin_2, OUTPUT);\n        pinMode(enable_pin_pwm, OUTPUT);\n        stop();\n}\n\nvoid TipperMotor::up() {\n        move(1023);\n        stop_dispatch.schedule(1*1000000, [this]() {\n                move(100);\n                hold_dispatch.schedule(1.5*1000000, [this]() {\n                        stop();\n                });\n        });\n}\n\nvoid TipperMotor::down() {\n        move(-1023);\n        stop_dispatch.schedule(0.48*1000000, [this]() {\n                stop();\n        });\n}\n\nvoid TipperMotor::disable() {\n        stop_dispatch.cancel();\n        stop();\n}\n\nvoid TipperMotor::move(int directional_speed) {\n        if (polarity)\n                directional_speed = -directional_speed;\n\n        if (directional_speed \n 0) {\n                digitalWrite(bridge_pin_1, HIGH);\n                digitalWrite(bridge_pin_2, LOW);\n        } else {\n                digitalWrite(bridge_pin_1, LOW);\n                digitalWrite(bridge_pin_2, HIGH);\n                directional_speed = -directional_speed; //abs\n        }\n\n        analogWrite(enable_pin_pwm, directional_speed);\n}\n\nvoid TipperMotor::stop() {\n        analogWrite(enable_pin_pwm, 0);\n}\n\n\n\nBuild Notes\n\n\nIf you want to compile the above code, there are some changes you need to make to the Arduino environment.\n\n\nWe need to link against the C++ standard libraries for the lambdas in our interrupt driven code. Link against it like so:\n\n\nOn macOS, open terminal and run:\n\n\nopen /Applications/Arduino.app/Contents/Java/hardware/teensy/avr/boards.txt\n\n\n\nEquivalent windows path:\n\n\nC:\\Program Files (x86)\\Arduino\\hardware\\teensy\\avr\\boards.txt\n\n\n\nChange\n\n\nteensy31.build.flags.libs=-larm_cortexM4l_math -lm\n\n\n\nto\n\n\nteensy31.build.flags.libs=-lstdc++ -larm_cortexM4l_math -lm\n\n\n\nYou (of course) need to have installed Teensy\u2019s dev environment inside of Arduino.\n\n\nWithin it, do not turn on link-time optimization (LTO). There is a bug that invalidates lambdas.\nTools\u2192Optimize should be set to \u201cFastest\u201d. If that\u2019s taking up too much program memory, switch to \u201cSmallest\u201d for a dramatic reduction on program size.\n\n\nCode Download\n\n\nThe full, zipped sketch can be downloaded \nhere\n.\n\n\n\n\nRobot Fabrication\n\n\n\n\nSystem Layout and Integration using 3D CAD\n\n\nMASTER%20ASSEM%20%28Converted%29.mov\n\n\nThe robot was structured around a three tiered system. We first decided to do a single global layout file to dictate locations for all the elements of the system. This ensured that from the start we could prevent interferences that are often the downfall of semi-complex integrated systems. From this master file, we were able to break out individual parts using an interlocking tab design for laser cutting. The standoffs that hold the drive axles are captive between the first and second deck which are clamped with threaded rods. Working from the ground up, we integrated a skirt to prevent debris on the game board from interfering with the drive system. In between the first and second decks of the robot, we placed the mechanical drive system. The second deck had the motors and gearheads placed closely to two motor driver modules, tape sensor, beacon circuit and limit switches through internal built in wiring pass throughs in the deck. Mounting points were integrated in the CAD model to create laser cut parts that were easy to assemble.\n\n\nWe put clean wire layout as an important design consideration opting for ribbon bales and tape tie downs throughout the robot. The teensy was placed in the center and connected to the motor driver modules. The level also supported a brace for the ball depositing mechanism and solenoid mounts. The batteries were placed such that they would counter the mass of the motors and provide a roughly centered center of gravity. The third and highest deck supported the upper side of the solenoid mounts and ball depositing system as well as the tipper drive and beacon sensing system.\n\n\n\n\n\n\n\n\nCAD master layout.\n\n\nDrive deck\n\n\n\n\nCollars prevent axial motion of the drive system which prevents the wheels and gears from rubbing on the chassis.\n\n\n\n\nCut outs in the bottom allow the wheels and gears more space and make tightening set screws easier during assembly.\n\n\nElectrical system deck\n\n\n\n\nThe e-stop is easily accessible from the side. Side by side pins were routed to side by side pins on the teensy for clean wiring.\n\n\n\n\nDrive motor and gearhead offer a 51:1 reduction.\n\n\n\n\nThe solenoids are held captive in vertical members and locked in place using a nut.\n\n\nTop deck\n\n\n\n\nGreen tape holding together a cracked gear housing. The free bin is always a mixed bag.\n\n\nManufacturing\n\n\n\n\nFront view shows base construction, welded tipping arm, machined ball tubes, and laser-cut duron layers.\n\n\nWhile the base and support structure were a relatively standard threaded rod and lasercut duron approach, we used more advanced manufacturing strategies for our tipping mechanism and ball dispensing mechanism to ensure reliability.\n\n\nThe ball dispensing tubes have machined slots and holes in precise locations, so that the limit switches and solenoids sat reliably in place for proper actuation. Our alignment pins for these tubes were out of spec, so the tubes moved slightly, causing the solenoids to bind and the limit switches to not trigger; however, we were able to fix this by realigning and locking the tubes in place.\n\n\nThe tipper arm was the most difficult manufacturing challenge on our robot, and was the most fun to create. Do to the 12\u201d cubic bounding box defined by the project and the amount of force we wanted from the arm, we decided to make it out of steel and aluminum. The arm was a welded steel lever that had a thickened plate at the tip for consistent tipping, and holes for a hinge and pulley string. When discussing welding Chris, wanted to weld so we taught him how and he welded the final tipper arm.  Additionally, we formed the spring for the arm out of 1/16\u201d spring steel wire, machined the aluminum attachment bracket, turned and machined angled washers for angle adjustment, wood turned the pulley and formed the two brackets for ensuring proper extension and retraction of the arm. Using a variety of processes, we were able to explore our interests and solve problems not easily fixed by a laser cutter. These reliable and robust systems allowed us to run the robot for 5-10 rounds before rechecking all the critical functions using a \u2018pit stop\u2019 checklist, and only using a short pre-round checkoff list each time.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-team-0-group-llc", 
            "text": "", 
            "title": "The Team 0 Group, LLC"
        }, 
        {
            "location": "/#winners-of-the-2018-me210-mechatronics-bracket", 
            "text": "", 
            "title": "Winners of the 2018 ME210 Mechatronics Bracket!"
        }, 
        {
            "location": "/#the-team-meet-the-members", 
            "text": "Joe Sunde          | Mechanical Engineering Co-term  Christopher Sauer  | Computer Science Co-term  Shalini Ranmuthu   | Electrical Engineering Master\u2019s  Kyle Feldmann      | Mechanical Engineering Co-term  (from left)", 
            "title": "The Team: Meet the Members"
        }, 
        {
            "location": "/#the-objective-game-play-and-rules", 
            "text": "ME 210 is a course that gives students an opportunity to dive into the world of mechatronics (intelligent electro-mechanical design).  The course\u2019s final assignment is a 3.5 week team project to create an autonomous bot that completes a series of tasks and can compete against the other 24 bots in the class.  This year\u2019s task was startup themed, the goal of the robot was to dispense balls (Buzzwords) into seesaw like boxes (Funding Rounds and Patent Offices) and to control at least two of them(A and B, or PO and B) to open the gate. Once the gate is open the bot can drive through and enter their opponent\u2019s starting area (Startup Garage) and win the game (acquire the opponent).  The robot can only carry 4 balls at a time and can only reload in the Incubator. The robot only has the walls, black and grey tape on the ground, and a series of IR beacons of different frequency and duty cycle to base its gameplay off of. The task must be completed in 2 minutes and 10 seconds, at which time the robots shut off and whoever has placed the most balls in the Funding Rounds wins.   The Map of \u2018Silicon Valley.\u2019", 
            "title": "The Objective: Game-Play and Rules"
        }, 
        {
            "location": "/#the-evidence-competition-results", 
            "text": "Our robot, configured as in competition.   Victory in the bracket.", 
            "title": "The Evidence: Competition Results"
        }, 
        {
            "location": "/#final-round", 
            "text": "", 
            "title": "Final Round"
        }, 
        {
            "location": "/#semi-final-round", 
            "text": "", 
            "title": "Semi-Final Round"
        }, 
        {
            "location": "/#quarter-final-round", 
            "text": "", 
            "title": "Quarter-Final Round"
        }, 
        {
            "location": "/#sweet-16-round", 
            "text": "", 
            "title": "Sweet 16 Round"
        }, 
        {
            "location": "/#the-strategy-discussing-design-choices", 
            "text": "The group set out from the start with the goal of not only meeting the minimum design requirements but also being competitive in the showcase at the end. While there is no grading benefit to winning, we wanted to have a robot the whole group was proud to share with the class and beyond Stanford. We quickly realized based on our motor selection from the free bin that one of the strengths of the robot was the available motor torque and speed. We knew it would drain power quickly, but provided we had enough power, we would be able to execute a strategy based on making quick maneuvers. Initial testing off a DC power source led us to decide to step down the gear ratio from the gear head slightly in our chain drive. We built a robot around coordinate motion to eliminate time lost in turning, and most importantly, we decided that using a line following strategy would be needlessly slow and instead opted for a physical wall following strategy. This decision had some major benefits. The first is that on a linked coordinate drive system any wander in the system (ie tendency to drive on a curve rather than line) is not correctable by the robot drive system. However, the walls of the course itself allow the edges of the robot to correct its trajectory if the cross drive provides some small amount of force holding the robot against the wall. This is perfect since the funding round bins are located against the wall. Instead of having to stop at each bin and advance from the tracking line, we could execute a \u201cdrive by\u201d ball deposit strategy. The coordinate motion strategy also eliminated the need to execute a turn to get through the gate further reducing the cycle time for the robot. Wall tracking allows another benefit in that simple limit switches can be used for tracking the position of the robot. Unlike tape sensors with varying thresholds based on light conditions, tape color, and cracks, limit switches offer a very binary measure of whether the robot has found a limit of the board.  After many close readings of the rules we decided on a competition strategy that included tipping Funding Round A (but not depositing any balls), depositing 3 balls into the Patent Office( ensuring that it would remain in our favor at least until the other team reloaded), and depositing a required 1 ball in Funding Round B while tipping it.  We would repeat this process as many times as we felt would be entirely reliably, as occasionally we would count an extra line before Funding Round A or misfire a ball. We established that two runs through would be enough to ensure that we would have control of at least one of the rounds, so on our subsequent reloads we strategized to dispense 4 balls into the patent office to protect it, and only tip the Funding Rounds.  With our speed and tipping power, we knew that no teams could beat us outright, and that we could tip 25 balls or more from the opponent's side, so we were not worried about teams who filled our Funding Round B only, and not worried about teams taking both A and B while we were reloading.  This methodology differed crucially from our checkoff where we were required to deposit balls in A and B and tipping had no bearing.", 
            "title": "The Strategy: Discussing Design Choices"
        }, 
        {
            "location": "/#the-takeaway-lessons-learned", 
            "text": "One of the pitfalls that is often an easy trap for engineers is the belief that because we have the tools to implement complex solutions these methods are the best way to solve a problem. Choosing simpler solutions early on that didn\u2019t require lots of tuning increased reliability and preserved flexibility for the new challenges and strategies that came up once the game board was finalized.  A perfect example of this is the implementation of threshold sensing using photo-transistors or more neatly tape sensors. In the lab we learned how to design and tune these systems using signal conditioning circuits and comparators with hysteresis. Having this immediate knowledge it is tempting to build a robot that only views its world through tape sensors and IR beacons. However, limit switches are incredibly reliable and provide a useful binary response that takes some threshold calibration to get from IR phototransistors. For a robot living in a world bounded by insurmountable walls, is it necessary to make use of this technology? Our answer we found was yes but to much less a degree than many teams chose. Our initial design included four or six tape sensors. What we quickly realized was that we could simply use one and still be much faster and more efficient than most designs that used several.  A second major lesson was that friction in real systems can be a real wild card. A significant number of robots in the competition or in practice would seemingly get inexplicably grabbed by walls or cracks in the floor or turn unexpectedly. We experienced this the night before the competition testing some final lines of code. The robot would get hung up on the return to the incubator which we determined was because of a small piece of tape on the wall. To this end we found that for our wall following design, bearing casters on the face really helped provide a predictable response.  There is often not one right answer, but at the end of the day, the team does need to make a decision and execute it well. For multiple components of the design there were competing design strategies. However, once the team decided on one, the whole group worked to implement it and continue designing from that point. Sometimes decisions you think are questionable at the beginning end up being much better than you thought. When multiple good options are available and there\u2019s disagreement within the team, it\u2019s critical to reach consensus and all commit to designing a single solution.  Finally building something for a theoretical challenge is more difficult than building for what is in front of you. The late arrival of the game board forced us to make our best guesses about what to expect. One thing we did not account for was how close the beacons would be to the edge of the game board. We also could not predict exactly how the funding rounds would respond to a tipping force. As designers, we had to figure out how to build in flexibility in the physical robot itself and how we structured the code. Defining an architecture early on allowed changes at these later stages to be much simpler and less stressful.", 
            "title": "The Takeaway: Lessons Learned"
        }, 
        {
            "location": "/#electrical-and-mechanical-design", 
            "text": "", 
            "title": "Electrical and Mechanical Design"
        }, 
        {
            "location": "/#schematic", 
            "text": "", 
            "title": "Schematic"
        }, 
        {
            "location": "/#teensy-pinout", 
            "text": "teensy PIN #  teensy PIN type  connecting PIN #  Function      0  DIGITAL_OUT  driver1 in1  N/S motor+    1  DIGITAL_OUT  driver1 in2  N/S motor-    2  DIGITAL_OUT  driver1 in3  E/W motor+    3  DIGITAL_OUT  driver1 in4  E/W motor-    4  PWM  driver1 en1  N/S motor    5  PWM  driver1 en2  E/W motor    6  DIGITAL_OUT  driver2 in1  ramp sol top    7  DIGITAL_OUT  driver2 in2  ramp sol bottom    8  DIGITAL_OUT  driver2 in3  tipper motor    9  DIGITAL_OUT  driver2 in4  tipper motor    10  PWM  driver2 en2  tipper motor    11  INPUT_PULLUP  limit switch  ramp switch top    12  INPUT_PULLUP  limit switch  ramp switch bottom    14  ANALOG_INPUT  phototransistor  tape sensor    15  INPUT_PULLUP  limit switch N  wall bumper    16  INPUT_PULLUP  limit switch E  reloading bumper    17  INPUT_PULLUP  limit switch S  start/back bumper    18  ANALOG_INPUT  op-amp output  beacon sensor", 
            "title": "Teensy Pinout"
        }, 
        {
            "location": "/#robot-subsystems", 
            "text": "", 
            "title": "Robot Subsystems"
        }, 
        {
            "location": "/#power-supply-and-drivers", 
            "text": "Power to the robot was provided by two Gens Ace 7.2V 3000mAh batteries connected in series to form the 14V supply (although actual voltage was slightly higher). A 15A breaker switch was placed in series with the power supply and functioned as an overall power switch. The power supply was connected to both of the L298N drivers, which are rated for at least a 35V supply. The L298N driver boards also have a built-in 5V voltage regulator, and one of these regulator outputs was used to power the Teensy, the tape sensing circuit, and the beacon sensing circuit. A 220uF bypass capacitor was used to stabilize the 5V power line.  The L298N drivers themselves are dual H bridge motor drivers, which means that we could control 4 total motors with this setup. We ended up driving 2 wheel motors, 1 tipper arm motor, and 2 solenoids (8 total outputs) using 8 inputs and 4 enable lines (wired as shown in the schematic).", 
            "title": "Power Supply and Drivers"
        }, 
        {
            "location": "/#drivetrain", 
            "text": "We decided to have the robot execute coordinate movement instead of a more traditional isolated two wheel drive. Mechanically, we decided to use two motors with two full width drive axles mechanically linking the advance ratio of each set of drive wheels. We used omni-directional wheels to allow this type of drive system. One of the concerns early on with this system was making sure all wheels are uniformly in contact with the ground at all times to ensure the robot would drive in a straight orthogonal grid. We used a captive design to place pillars holding shoulder bushings and 4 mechanical supports per axle (two closely placed around each drive wheel) The accuracy and repeatability of CAD driven laser cutting allowed easy alignment of the bearing axes and ensuring that all four wheels would contact the ground well. We sized the drive wheels to be 4 inches on one axis and 3.25 inches on the other axis so that the axles could cross each other without interference. We prototyped the drivetrain train levels to confirm our design would work before continuing with the upper level design. Initially, there was enough tolerance variation that the axles would bind in the bushing, so the bearings were opened up a few thousandths of an inch to allow free rolling. The second deck of the robot was the integrated electronics and drive motor deck. This area was more accessible with more space and was thus easier to work in. The axles were connected through the deck with a chain drive system to the DC motors mounted on brackets on top of the second deck. The brackets were mounted in slots to allow proper chain tensioning after the chain was assembled.", 
            "title": "Drivetrain"
        }, 
        {
            "location": "/#wall-tracking", 
            "text": "After being forewarned about the pitfalls of line sensing, we developed another motion sensing system for robust tracking. The wall tracking method consisted of three limit switches mounted to the lower level of the robot on the front, right and rear sides of our bot, in a way that when they are fully engaged the roller sits flush with the outside edge of the robot.  We used wall tracking to trigger our interrupts, and to ensure that we were reaching our desired destinations for dropping balls, tipping, reloading, and finishing a round.", 
            "title": "Wall Tracking"
        }, 
        {
            "location": "/#ball-dispensing", 
            "text": "From the start we focused on a simple, robust ball dispensing system. Our ball dispensing system used a pvc tube mounted to a vertical duron board. This tube has holes for a limit switch and a solenoid. The limit switch was used to sense if balls were loaded into the tube, and the solenoid to quickly and reliably dispense balls. The reason we decided to use a solenoid rather than a servo was that it allowed us to more quickly dispense balls while driving quickly, and gave us the ability to dispense one ball at a time if necessary.  We also decided to have two separate ball dispensing systems so that we could selectively load balls depending on the desired functionality. While giving the robot information based on game events was not allowed in a rules update, our system let us load balls in a specific pattern so that we could dispense in different bins after each reload. We ended up using a strategy of dispensing 3 balls into the Patent Office and one into Funding Round B for the first two reloading cycles, and 4 into the Patent Office for each successive reloading cycle.  We also used modified syringes to quickly reload our dispensing tubes cutting reloading time by about 1.5 seconds over hand-loading.", 
            "title": "Ball Dispensing"
        }, 
        {
            "location": "/#tape-sensing", 
            "text": "We used tape sensing as a secondary sensing system to determine when we were in front of the funding rounds, patent office, or gate. We designed for enough room to integrate three sensors along the bottom of our robot along a threaded rod, but ended up only needing one on the left side of the robot to sense the grey tape marking the funding round locations and the tape marking the gate location. We decided to put the sensor on the left of the robot to give us time to drive and shoot near full speed.  The tape sensor itself consists of the OP265 photodiode and the OP535 phototransistor. The diode drop was measured to be 1.16V. In order to limit the current through the diode to the recommended 40mA and account for some safety margin, we rounded the drop down to  1V , leaving  5V-1V=4V  to drop in series with the LED. This resulted in a required resistance value of   \\frac{4V}{40mA} = 100\\Omega . From the OP535 datasheet current curves, we initially used a  1k\\Omega  resistor in a sourcing configuration, but we found upon experimentation that a  10k\\Omega  resistor gave a better range.  The low-clearance skirt for our robot was able to block most light and our sensor remained in calibration for our purposes after a few initial calibration tests before checkoff.  The values from these calibration tests are shown in the table below. With the calibrated thresholds, we could detect the white game board as well as black, grey, and green tape. We also filtered out cracks and other small objects by sampling at least twice per grey tape width and then checking that we read two of the same tape color value sequentially before reacting to it.      Test Circuit Values (2/20/18)  Actual Robot Readings (2/27/18)  New Tape Sensor Position (3/2/18)  Different Lighting (3/3/18)      White (no tape)  1023 (just above saturation. Measured as 3.34V)  880  560  950    Black  125  95  50  100    Grey  400  310  160  300    Green  910  480  260  690", 
            "title": "Tape Sensing"
        }, 
        {
            "location": "/#tipper-arm", 
            "text": "After checking off the basic functionality of the robot, the team decided that the next highest priority for the robot was developing a tipping mechanism. The reasoning was that against a highly functional opponent, in increasingly later game states it would be difficult to regain control of funding rounds by simply dumping balls. In essence, the tipper is the game changer, we could not imagine robots without that level of functionality prevailing against robots with it. Our initial design ideations centered around dropping a weight on a reel or a servo driven \u201cbow drill\u201d poker that provided linear actuation not unlike fire starters of the paleolithic age. We quickly realized that both these strategies limited the speed of our robot through the funding rounds and we would have to make strategy decision: Do we drop balls and move quickly or do we stop to tip? Additionally, when would we know when to tip and how could we pick up the state of the beacon from the funding round before committing to a robot deceleration. These questions sent us back to the drawing board looking for a better solution.  We thought about quick acting high energy sources for quick funding round tipping. Compressed springs or dynamic linkages could provide faster action but would prove complicated. Another idea occurred which was to use on board compressed air to blast a jet of air against the funding round. It wouldn\u2019t be dangerous and violate the safety guidelines but it would provide a dynamic fast acting tipper that would allow drive by tipping along with ball dropping. We started experimenting with air in a can as even the low pressure delta could still provide a regulated choked flow at a pre-sized converging nozzle for air (k = 1.4 requires a minimum delta P of ~ 2) We quickly realized though that the available volume in these cans was fairly small, and the required mass flux was relatively high. We measured tipping force for the funding rounds around 300g and calculated that we would need a minimum nozzle orifice of .05 inch OD. The issue with this was that in testing 10 L allowed us to get 2-3 tips. Using a high pressure CO2 disposable cartridge we could easily get 10L for $2-3. It would be difficult to get more than 10 L in a hand-pumped air canister which we could feasibly get up to 150 psi. However, to get repeatable tips in a round we wanted more and thus started thinking about using refillable liquid CO2 canisters. We did some quick research and realized that this would not only be a hassle but was definitely outside the available funding range for the robot.  The team went back to the drawing board a second time and came up with the idea of a \u201csnow plow\u201d tipper. This tipper would operate while driving and be able to bounce over the funding rounds applying a tipping impulse and bounce over the wall of the game board if necessary. The first conceptual version was a stiff steel spring mounted between two points that could be brought towards each other thus lowering the plow into tipping position. Through its compliance, it would be able to depress the funding rounds without causing damage to the robot. Finding the right spring material proved a challenge though so we switched to the idea of a weighted swing arm that could be pulled up by a non-backdriveable DC motor. At first the arm did not reach the funding bins so shims and an angled guide were used to get the arm to extend out further.", 
            "title": "Tipper Arm"
        }, 
        {
            "location": "/#reloading-mechanisms", 
            "text": "Using a coordinate drive system allowed us to trigger the reload beacon by driving directly into it. The robot was able to register a reload through limit switches placed as obstructions at the entrance of each tube (switch would be triggered as balls passed through into the tube). In order to load the balls quickly, we fabricated custom ball loaders out of large plunger syringes. The end was modified to have a flap valve that allowed the balls to be pushed through. A fast reloading mechanism allowed the software to wait for a much shorter time before assuming reloading was complete.", 
            "title": "Reloading Mechanisms"
        }, 
        {
            "location": "/#beacon-sensing", 
            "text": "We decided that the easiest and fastest strategy would be to only read the beacon at the gate, and not have to worry about filtering in hardware (especially since the signals were square waves and not sinusoidal) or checking the frequency in software (would require some wait wait time) to separate and read the different beacon signals. This allowed us to just use an active high-pass filtering circuit (inverting topology) to remove DC interference as well as 60Hz noise from the overhead lights. We initially added a single phototransistor to the input of this filter in a sourcing configuration to sense the LED beacon. However, since each phototransistor has a fairly narrow field of view, we used 4 phototransistors connected in parallel and physically arranged to be facing slightly different angles but at the same height. This allowed us to repeatedly sense the gate beacon despite slight changes in the robot orientation. Since the gate beacon has the highest duty cycle frequency of 4125Hz and the next highest beacon is at 3500Hz, the filter was designed to have a cutoff frequency of  f_c = \\frac{1}{2\\pi R_1C} = \\frac{1}{2\\pi*470\\Omega*0.1\\mu F} \\approx 3390 Hz . The gain was set to  A = \\frac{-R_2}{R_1} = \\frac{-100k\\Omega}{470\\Omega} = -213  .  In order to avoid reading the frequency in software and also to smooth out sudden fluctuations in sensor readings, a 1uF capacitor was added as an integrator to the output of the active filter (which would affect the theoretical gain calculated above). We experimented with smaller capacitor values, but found the time constant was too small to effectively smooth out the duty cycle. The result of this design was that the input to the Teensy would now be a steady value that represented the average of the amplified duty cycle, instead of the duty cycled signal itself. When the beacon was on, this amplified average value would be around 1V whereas it would be close to 0.05V when the beacon was off. This simplified the software\u2019s job to quickly reading an analog value, which it would then compare to some experimentally determined threshold value.", 
            "title": "Beacon Sensing"
        }, 
        {
            "location": "/#bill-of-materials", 
            "text": "Quantity  Part Name  Part Number      2  4\" Omni Wheel  Vex 276-3525    2  3.25\" Omni Wheel  Vex 276-2185    2  Planetary Gear 12 V DC Motor  ServoCity638278    2  1/4\" Axle Machined     2  Gens Ace 7.2V 3000mAh battery     1  3ft Chain  .25\" pitch    2  Chain Connecting Links  .25\" pitch    2  16 Tooth Sprockets  .25\" pitch    2  23 Tooth Sprockets  .25\" pitch    8  Bushing, flanged, 1/4\" ID x 1/4\" long  McMaster3746K2    4  Collar, set screw, steel, 1/4\"  ServoCity 6432K12    2  Solenoid  Jameco 2202335    2  castor wheels     1  Large threaded rod  1/4-20    2  Small Threaded Rods  10-32    2  Duron 18\"x 24\"     1  misc. small hardware     1  DC Motor from free bin     1  Woodturned Pulley     1  Welded steel tipping arm  Stainless Steel    1  Machined Tipping Arm Mount  6061 Aluminum    2  Machined PVC tubes  1.25\" PVC Tubing    4  Zip ties     1  Cotton String     1  15A Breaker  1724R13A    1  Teensy  V3.2    2  Half Proto-Boards     1  Tape Sensor  opb704wz    2  L298N motor driver     5  limit switches  jameco 2187905    50  Stranded Wires  as in schematic    3  Capacitors  as in schematic    5  Resistors  as in schematic    1  Op-Amp  LM324N    4  Phototransisotrs  LTR-3208E", 
            "title": "Bill of Materials"
        }, 
        {
            "location": "/#software", 
            "text": "", 
            "title": "Software"
        }, 
        {
            "location": "/#goals-and-philosophy", 
            "text": "Our software design philosophy was aligned with that for our mechanical and electrical design: Solve known challenges fast, while preserving the flexibility required to quickly address future challenges that arose as details about the game board and our competitors emerged.  Since software is a more malleable medium than hardware, we knew we could take valuable architectural risks if we started early. Software also benefits from hierarchical abstractions; finding the right abstractions early would dramatically speed development later.", 
            "title": "Goals and Philosophy"
        }, 
        {
            "location": "/#strategy-and-design-decisions", 
            "text": "Thus, code development began early and in parallel with hardware. We built test circuits for each component and wrote quick code to drive them. Then, offline, we\u2019d turn that test code into something robust and modular that would support all the functions we needed of that part of the robot.  We knew early that we would need to have many logical threads of execution running in parallel. As an example, the robot would need to simultaneously: track the north wall, lower its tipper, deposit balls, count grey tape lines, and move left. Each would be driven by interrupts and run very quickly.  Traditional threading was the wrong solution, even if Teensy Threads were available. Preemptive multitasking requires sophisticated concurrency control mechanisms and tends to leak state through abstractions.  Cooperative multitasking was clearly a better and simpler solution. Since we\u2019re running on a single-core system and each routine runs extremely quickly, it would save us from most concurrency-related bugs.  Teensy Fibers didn\u2019t seem to provide the right interface around interrupts, so we settled on building our own interrupt-driven infrastructure.", 
            "title": "Strategy and Design Decisions"
        }, 
        {
            "location": "/#beginning-from-the-end", 
            "text": "It\u2019s easiest to explain the abstractions we chose by starting with the final sketch we wrote. We\u2019ll explain what properties we wanted it to have and then building upwards through the dependency graph of C++ libraries we wrote to support it.  //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DriveMotor.hpp\"\n#include \"LaunchTube.hpp\"\n#include \"TapeSensor.hpp\"\n#include \"TipperMotor.hpp\"\n\nstatic LaunchTube upperTube(6, 11, 1); //solenoid pin, switch pin, initial ball count\nstatic LaunchTube lowerTube(7, 12, 3);\n\nstatic DriveMotor xAxisMotor(2, 3, 5, true, 16); //out1 pin, out2 pin, en pin, direction, switch pin\nstatic DriveMotor yAxisMotor(0, 1, 4, false, 15, 17);\n\nstatic TipperMotor tipper(8, 9, 10, false); //out1 pin, out2 pin, en pin, direction\n\nstatic TapeSensor tapeSensor(14, 15000); //phototransistor pin, minimum microsec over a line\nstatic const uint32_t GATE_SENSOR_PIN = 18;\n\nstatic uint32_t startMillis = 0;\n\nstatic int greyCount = 0;\nstatic int greenCount = 0;\n\nvoid setup() {\n  // Init serial object.\n  Serial.begin(0); // Baud rate ignored. Teensy USB is always standard 12 Mbit/sec\n  analogWriteResolution(10); // Real resolution at this frequency.\n  pinMode(GATE_SENSOR_PIN, INPUT);\n  Serial.println(\"Booted\");\n\n  yAxisMotor.notifyOnNextNegativeLimitPress([]() {\n    startMillis = millis();     // Stop play at 2:10\n    primaryPass();\n    Serial.println(\"Started\");\n  });\n}\n\nstatic void primaryPass() {\n  xAxisMotor.timedMove(-1023, 0.4*1000000, []() {\n    yAxisMotor.moveToLimit(400, []() {  //go @ 400 power until we hit wall track switch\n      tipper.down();\n      xAxisMotor.move(-420);\n      yAxisMotor.trackPositiveLimit(400);\n      greyCount = 0;\n      tapeSensor.observeGrey([]() {\n        greyCount++;\n\n        if (greyCount == 1) { //hit first grey line\n          xAxisMotor.timedMove(0, 0.8*1000000, []() {\n            xAxisMotor.move(-340);\n          });\n        } else if (greyCount == 2) { //hit second grey line\n          xAxisMotor.stop();\n          lowerTube.dumpBallsPresent([]() {\n            xAxisMotor.move(-370);\n          });\n        } else if (greyCount == 3) {  //hit third grey line\n          upperTube.dumpBallsPresent([]() {});\n          tapeSensor.stopObserving();\n          thirdGreyToGateAttempt();\n        }\n      });\n    });\n  });\n}\n\nstatic void thirdGreyToGateAttempt() {\n  yAxisMotor.stopTrackingPositiveLimit(); // Stop hugging wall to avoid turning\n  xAxisMotor.timedMove(0, 1.5*1000000, []() {\n    tipper.up();\n    xAxisMotor.move(-400); //not full speed so you don't slam into wall by the gate\n    tapeSensor.observeBlack([]() {  //hit black line in front of gate\n      tapeSensor.stopObserving();\n\n      xAxisMotor.stop();\n\n      if (gateOpen()) {\n        // Sprint until we've won, then slowly drive through to the wall.\n        yAxisMotor.move(1023);\n        greenCount = 0;\n        tapeSensor.observeGreen([]() {\n          greenCount++;\n          if (greenCount == 2) {\n            yAxisMotor.moveToLimit(300, []() {\n              // We've won!\n              disableAll();\n            });\n          }\n        });\n      } else {\n        moveToReload();\n      }\n    });\n  });\n}\n\nstatic void moveToReload() {\n  // Timed sprint toward South wall\n  yAxisMotor.timedMove(-1023, 0.4*1000000, []() {\n    // Finish moving South\n    yAxisMotor.moveToLimit(-500, []() {\n      // Pull away from South wall to reduce friction\n      yAxisMotor.timedMove(400, 0.6*1000000, [](){});\n\n      // Timed sprint toward East wall\n      xAxisMotor.timedMove(1023, 3.1*1000000, [](){ //~3.5\n        // Finish moving East and stay there\n        xAxisMotor.moveToLimit(500, []() {\n          xAxisMotor.timedMove(1023, 0.05*1000000, [](){}); // back off just a bit\n\n          // Go up and hit the button.\n          yAxisMotor.trackPositiveLimit(600);\n          // wait for reload, then continue\n          lowerTube.notifyOnNextLoad([](){\n            yAxisMotor.stopTrackingPositiveLimit();\n            xAxisMotor.stopTrackingPositiveLimit();\n            secondaryPass();\n          });\n        });\n      });\n    });\n  });\n}\n\nstatic void secondaryPass() {\n  // Reset against round wall\n  yAxisMotor.timedMove(-400, 0.3*1000000, [](){});\n  xAxisMotor.timedMove(-1023, 1.0*1000000, [](){\n    yAxisMotor.moveToLimit(400, [](){\n      tipper.down();\n      yAxisMotor.trackPositiveLimit(400);\n      xAxisMotor.move(-1023);\n\n      greyCount = 0;\n      tapeSensor.observeGrey([]() {\n        greyCount++;\n\n        if (greyCount == 1) { //hit first grey line\n          xAxisMotor.timedMove(0, 0.8*1000000, []() {\n            xAxisMotor.move(-340);\n          });\n        } else if (greyCount == 2) { //hit second grey line\n          xAxisMotor.stop();\n          lowerTube.dumpBallsPresent([]() {\n            xAxisMotor.move(upperTube.hasBalls() ? -370 : -1023);\n          });\n        } else if (greyCount == 3) {  //hit third grey line\n          if (upperTube.hasBalls()) {\n            upperTube.dumpBallsPresent([]() {\n              tapeSensor.stopObserving();\n              thirdGreyToGateAttempt();\n            });\n          } else {\n            tapeSensor.stopObserving();\n            thirdGreyToGateAttempt();\n          }\n        }\n      });\n    });\n  });\n}\n\nstatic bool gateOpen() {\n  Serial.print(\"Gate says: \"); Serial.println(analogRead(GATE_SENSOR_PIN));\n  // return false;\n  return analogRead(GATE_SENSOR_PIN)   15;\n}\n\nstatic void disableAll() {\n   Serial.println(\"Disabled\");\n   upperTube.disable();\n   lowerTube.disable();\n   tapeSensor.stopObserving();\n   xAxisMotor.disable();\n   yAxisMotor.disable();\n   tipper.disable();\n}\n\nvoid loop() {\n  if (startMillis != 0   millis()   startMillis + (2*60 + 10) * 1000) {\n    disableAll();\n    startMillis = 0;\n  }\n  Serial.println(\"*\"); delay(500);\n}  Blocking code would have been extremely problematic given the concurrent and interrupt-driven requirements of the program. But you\u2019ll notice that the program reads (and writes!) almost as easily as blocking code would. You declare sequentially all the things you want to happen at the same time\u2014since the processor operates so fast compared to physical world time\u2014and declare the things you want to happen when the operation completes inside of completion handler. If you\u2019ve ever programmed for iOS, Grand Central Dispatch is somewhat similar. The callbacks are handled as C++11 lambdas, which turn code into a callable object with associated data.  Further, at the top level, everything is semantic. You declare what you want done\u2014move in the positive x direction for z seconds\u2014and the implementation is handled by the libraries.", 
            "title": "Beginning from the End"
        }, 
        {
            "location": "/#our-libraries-for-controlling-are-as-follows", 
            "text": "TapeSensor : Manages de-noising tape crossings and notifying the main program  DriveMotor : Controls a motor and its interaction with the limit switches tracking its position. Two instances, one for each coordinate axis.  LaunchTube : Manages launching balls, counting the number of balls loaded, and notifying the main program on reload. Two instances, one for each physical tube.  TipperMotor : Manages raising and lowering the tipper arm asynchronously.", 
            "title": "Our libraries for controlling are as follows:"
        }, 
        {
            "location": "/#theyre-supported-by-the-following-abstractions-around-timers-and-interrupts", 
            "text": "LambdaInterrupt : Modifies interrupts on digital pins to dispatch to lambdas instead of function pointers, as in Arduino\u2019s implementation.  DebouncedInterrupt : A version of the above that has a maximum firing frequency, easily adjustable in software.  LambdaTimer : IntervalTimer modified to call lambdas. Dynamically allocates itself onto one of the 4 hardware timers.  DispatchAfter : Uses a LambdaTimer to call you back once after a certain interval has elapsed. Then deallocated the timer.  MissingSystemFunctions : Fools the C++ standard libraries to link by faking like we\u2019re running on an OS.   You\u2019ll also see some other code in the main sketch. We implemented gate sensing directly in there because it was so few lines that it didn\u2019t merit an abstraction boundary. When interrupts aren\u2019t driving the code, the main loop prints out asterisks as a heartbeat to let us know that the program is still running. Without a debugger, that\u2019s the only easy way to know if our function-pointer shenanigans had crashed the program. Finally you\u2019ll notice that we implemented the kill timer by polling. We don\u2019t like it either, but it\u2019s too long for the hardware timers, and it\u2019s just using up whatever spare processing power isn\u2019t consumed by the interrupts.", 
            "title": "They\u2019re supported by the following abstractions around timers and interrupts:"
        }, 
        {
            "location": "/#infrastructure", 
            "text": "In order to understand how the higher level abstractions work, we first have to talk through the lower level ones.", 
            "title": "Infrastructure"
        }, 
        {
            "location": "/#lambdainterrupt", 
            "text": "The first obstacle is that Arduino\u2019s interrupt handling makes building object-oriented abstractions on top of it impossible. Since it only calls back function pointers, it can\u2019t associate data with the calls. That means it can\u2019t call back an instance of a class, which means you can\u2019t wrap logic you want to instantiate multiple off in a class. This is really bad.  Here\u2019s a solution, where we wrap Arduino\u2019s interrupt dispatch to make it call lambdas.  The syntax is a little obtuse, but basically we\u2019re just making a giant bank of functions that we always point the interrupts to. These functions just route the call to out std::function from a lookup table.  //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#pragma once\n\n#include  functional \n\n// Wrapper of Teensy Interrupts to support binding state with c++11 lambdas.\n// You need this functionality to be able to wrap interrupt calls inide of a class.\n// (You'll be much happier using this interface than looking at the implementation)\n\nnamespace LambdaInterrupt {\n        // Assumes you've already set the pinmode\n        void attach(uint8_t pin, uint8_t event_type, std::function void()  callback);\n        void detatch(uint8_t pin);\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LambdaInterrupt.hpp\"\n\n#include  Arduino.h \n\n// General stratedy: Define a fixed size block of functions, one per pin.\n// Those functions just dispatch the incoming call to the requested callback.\n\nnamespace LambdaInterrupt {\n\n        static std::function void()  callbacks[24]; // From user\n\n// Begin: Dispatch table code\n#define DISPATCH_FN_FACTORY(n) static void _isr_dispatch_##n() { callbacks[n](); }\n        DISPATCH_FN_FACTORY(0) DISPATCH_FN_FACTORY(1) DISPATCH_FN_FACTORY(2)\n        DISPATCH_FN_FACTORY(3) DISPATCH_FN_FACTORY(4) DISPATCH_FN_FACTORY(5)\n        DISPATCH_FN_FACTORY(6) DISPATCH_FN_FACTORY(7) DISPATCH_FN_FACTORY(8)\n        DISPATCH_FN_FACTORY(9) DISPATCH_FN_FACTORY(10) DISPATCH_FN_FACTORY(11)\n        DISPATCH_FN_FACTORY(12) DISPATCH_FN_FACTORY(13) DISPATCH_FN_FACTORY(14)\n        DISPATCH_FN_FACTORY(15) DISPATCH_FN_FACTORY(16) DISPATCH_FN_FACTORY(17)\n        DISPATCH_FN_FACTORY(18) DISPATCH_FN_FACTORY(19) DISPATCH_FN_FACTORY(20)\n        DISPATCH_FN_FACTORY(21) DISPATCH_FN_FACTORY(22) DISPATCH_FN_FACTORY(23)\n#undef DISPATCH_FN_FACTORY\n\n        static void (*isr_dispatch_table[])() = {\n                _isr_dispatch_0, _isr_dispatch_1, _isr_dispatch_2,\n                _isr_dispatch_3, _isr_dispatch_4, _isr_dispatch_5,\n                _isr_dispatch_6, _isr_dispatch_7, _isr_dispatch_8,\n                _isr_dispatch_9, _isr_dispatch_10, _isr_dispatch_11,\n                _isr_dispatch_12, _isr_dispatch_13, _isr_dispatch_14,\n                _isr_dispatch_15, _isr_dispatch_16, _isr_dispatch_17,\n                _isr_dispatch_18, _isr_dispatch_19, _isr_dispatch_20,\n                _isr_dispatch_21, _isr_dispatch_22, _isr_dispatch_23\n        };\n// End: Dispatch table code\n\n        void attach(uint8_t pin, uint8_t event_type, std::function void()  callback) {\n                callbacks[pin] = callback;\n                attachInterrupt(digitalPinToInterrupt(pin), isr_dispatch_table[pin], event_type);\n        }\n\n        void detatch(uint8_t pin) {\n                detachInterrupt(digitalPinToInterrupt(pin));\n        }\n};", 
            "title": "LambdaInterrupt"
        }, 
        {
            "location": "/#debouncedinterrupt", 
            "text": "We\u2019ll then wrap the above to have a maximum firing frequency, easily adjustable in software. This increases our development speed, because it saves having to build filters and hysteresis circuits.  It works by storing the last call time and suppressing callbacks that occur too quickly after the first one.  We wrote this class primarily for counting balls going into the launch tubes.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DispatchAfter.hpp\"\n\nclass DebouncedInterrupt {\npublic:\n        // Usage example for an even that could happen at most 4 times a second:\n        // DebouncedInterrupt(10, INPUT_PULLUP, FALLING, 250000 /*us*/, [this]() {\n        //         // Respond to event.\n        // });\n        DebouncedInterrupt(uint8_t pin, uint8_t pinmode, uint8_t event_type, uint32_t min_period /*us*/, std::function void()  callback);\n        ~DebouncedInterrupt();\n\n        // For detecting after a debounced burst has finished.\n        void dispatchAfterBurstFinish(uint32_t max_time_between_triggers, std::function void()  callback);\n\n        // Stops you getting callbacks on this pin.\n        void disable();\n\nprivate:\n        DispatchAfter burst_finish;\n        std::function void()  burst_callback;\n        uint32_t max_time_between_triggers;\n\n        const uint8_t pin;\n        const std::function void()  callback;\n        const uint32_t min_period;\n        uint32_t last_fire;\n        bool active;\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"DebouncedInterrupt.hpp\"\n\n#include \"LambdaInterrupt.hpp\"\n\n#include  Arduino.h \n\n\nDebouncedInterrupt::DebouncedInterrupt(uint8_t pin, uint8_t pinmode, uint8_t event_type, uint32_t min_period, std::function void()  callback) :\n        pin(pin),\n        callback(callback),\n        min_period(min_period),\n        last_fire(0),\n        active(true)\n{\n        pinMode(pin, pinmode);\n        LambdaInterrupt::attach(pin, event_type, [this]() {\n                uint32_t curr_time = micros();\n                if (curr_time - last_fire  = this- min_period) {\n                        last_fire = curr_time;\n                        if (burst_callback) {\n                                // schedules for the first time or reschedules into the future\n                                burst_finish.schedule(max_time_between_triggers, [this]() {\n                                        burst_callback();\n                                        burst_callback = [](){};\n                                });\n                        }\n                        this- callback();\n                }\n        });\n}\n\nDebouncedInterrupt::~DebouncedInterrupt() {\n        disable();\n}\n\nvoid DebouncedInterrupt::dispatchAfterBurstFinish(uint32_t max_time_between_triggers, std::function void()  callback) {\n        this- max_time_between_triggers = max_time_between_triggers;\n        this- burst_callback = callback;\n}\n\nvoid DebouncedInterrupt::disable() {\n        if (active) {\n                burst_finish.cancel();\n                LambdaInterrupt::detatch(pin);\n                active = false;\n        }\n}", 
            "title": "DebouncedInterrupt"
        }, 
        {
            "location": "/#lambdatimer", 
            "text": "For the same reasons we needed to modify attachInterrupt, we need to change IntervalTimer modified to call lambdas. Here\u2019s a modified version of IntervalTimer. As with the original, it dynamically allocates itself onto one of the 4 hardware timers.  The trickiness in the code is in not deallocating lambdas while they\u2019re running. A naive implementation would delete running lambdas if they descheduled themselves while running\u2014especially if they reallocated another lambda in their place. This leads to really nasty bugs. Instead, we defer deallocation of internal resources until after the lambda call has ended.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n// Modernized by Christopher Sauer on 2/24/2018 to take lambdas instead of fnptrs\n\n/* Teensyduino Core Library\n * http://www.pjrc.com/teensy/\n * Copyright (c) 2017 PJRC.COM, LLC.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * 1. The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * 2. If the Software is incorporated into a build system that allows\n * selection among a list of target devices, then similar target\n * devices manufactured by PJRC.COM must be included in the list of\n * target devices and selectable in the same manner.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"kinetis.h\"\n\n#include  functional \n\nclass LambdaTimer {\nprivate:\n        static const uint32_t MAX_PERIOD = UINT32_MAX / (F_BUS / 1000000.0);\npublic:\n        LambdaTimer();\n        ~LambdaTimer();\n\n        bool active();\n\n        bool begin(uint32_t microseconds, std::function void()  callback);\n        void update(uint32_t microseconds);\n\n        void end();\n        void priority(uint8_t n);\n        operator IRQ_NUMBER_t();\n\nprivate:\n        friend void pit_isr();\n        friend void pit0_isr();\n        friend void pit1_isr();\n        friend void pit2_isr();\n        friend void pit3_isr();\n        void deallocResources();\n\n        KINETISK_PIT_CHANNEL_t *channel;\n        uint8_t nvic_priority;\n        #if defined(KINETISL)\n        static uint8_t nvic_priorites[2];\n        #endif\n        bool beginCycles(uint32_t cycles, std::function void()  callback);\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n// Modernized by Christopher Sauer on 2/24/2018 to take lambdas instead of fnptrs\n\n/* Teensyduino Core Library\n * http://www.pjrc.com/teensy/\n * Copyright (c) 2017 PJRC.COM, LLC.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * 1. The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * 2. If the Software is incorporated into a build system that allows\n * selection among a list of target devices, then similar target\n * devices manufactured by PJRC.COM must be included in the list of\n * target devices and selectable in the same manner.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"LambdaTimer.hpp\"\n\n#include  Arduino.h \n\n#if defined(KINETISK)\n#define NUM_CHANNELS 4\n\n#elif defined(KINETISL)\n#define NUM_CHANNELS 2\nuint8_t LambdaTimer::nvic_priorites[2] = {255, 255};\n#endif\n\nstatic std::function void()  funct_table[NUM_CHANNELS];\nstatic LambdaTimer* dealloc_on_exit[NUM_CHANNELS] = {nullptr};\n\nLambdaTimer::LambdaTimer() {\n        channel = nullptr;\n        nvic_priority = 128;\n}\n\nLambdaTimer::~LambdaTimer() {\n        deallocResources();\n}\n\nbool LambdaTimer::active() {\n        const int index = channel - KINETISK_PIT_CHANNELS;\n        return channel != nullptr   dealloc_on_exit[index] == false;\n}\n\nbool LambdaTimer::begin(uint32_t microseconds, std::function void()  callback) {\n        if (microseconds == 0 || microseconds   MAX_PERIOD)\n                return false;\n        uint32_t cycles = (F_BUS / 1000000) * microseconds - 1;\n        if (cycles   36) return false;\n        return beginCycles(cycles, callback);\n}\n\nvoid LambdaTimer::update(uint32_t microseconds) {\n        if (microseconds == 0 || microseconds   MAX_PERIOD) return;\n        uint32_t cycles = (F_BUS / 1000000) * microseconds - 1;\n        if (cycles   36) return;\n        if (channel) channel- LDVAL = cycles;\n}\n\nbool LambdaTimer::beginCycles(uint32_t cycles, std::function void()  callback)\n{\n        if (channel) {\n                channel- TCTRL = 0;\n                channel- TFLG = 1;\n        } else {\n                SIM_SCGC6 |= SIM_SCGC6_PIT;\n                __asm__ volatile(\"nop\"); // solves timing problem on Teensy 3.5\n                PIT_MCR = 1;\n                channel = KINETISK_PIT_CHANNELS;\n                while (1) {\n                        if (channel- TCTRL == 0) break;\n                        if (++channel  = KINETISK_PIT_CHANNELS + NUM_CHANNELS) {\n                                Serial.println(\"Out of timers\");\n                                channel = nullptr;\n                                return false;\n                        }\n                }\n        }\n        int index = channel - KINETISK_PIT_CHANNELS;\n        dealloc_on_exit[index] = nullptr;\n        funct_table[index] = callback;\n        channel- LDVAL = cycles;\n        channel- TCTRL = 3;\n#if defined(KINETISK)\n        NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);\n        NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);\n#elif defined(KINETISL)\n        nvic_priorites[index] = nvic_priority;\n        if (nvic_priorites[0]  = nvic_priorites[1]) {\n                NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);\n        } else {\n                NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);\n        }\n        NVIC_ENABLE_IRQ(IRQ_PIT);\n#endif\n        Serial.print(\"Allocating timer\"); Serial.println(index);\n        return true;\n}\n\nvoid LambdaTimer::end() {\n        if (channel) {\n                const int index = channel - KINETISK_PIT_CHANNELS;\n                dealloc_on_exit[index] = this;\n        }\n}\n\nvoid LambdaTimer::deallocResources() {\n        if (channel) {\n                int index = channel - KINETISK_PIT_CHANNELS;\n                Serial.print(\"Deallocating timer\"); Serial.println(index);\n#if defined(KINETISK)\n                NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);\n#elif defined(KINETISL)\n                // TODO: disable IRQ_PIT, but only if both instances ended\n#endif\n                funct_table[index] = std::function void() ();\n                channel- TCTRL = 0;\n#if defined(KINETISL)\n                nvic_priorites[index] = 255;\n                if (nvic_priorites[0]  = nvic_priorites[1]) {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);\n                } else {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);\n                }\n#endif\n                channel = nullptr;\n        }\n}\n\nvoid LambdaTimer::priority(uint8_t n) {\n        nvic_priority = n;\n        #if defined(KINETISK)\n        if (channel) {\n                int index = channel - KINETISK_PIT_CHANNELS;\n                NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);\n        }\n        #elif defined(KINETISL)\n        if (channel) {\n                int index = channel - KINETISK_PIT_CHANNELS;\n                nvic_priorites[index] = nvic_priority;\n                if (nvic_priorites[0]  = nvic_priorites[1]) {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);\n                } else {\n                        NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);\n                }\n        }\n        #endif\n}\n\nLambdaTimer::operator IRQ_NUMBER_t() {\n        if (channel) {\n                #if defined(KINETISK)\n                int index = channel - KINETISK_PIT_CHANNELS;\n                return (IRQ_NUMBER_t)(IRQ_PIT_CH0 + index);\n                #elif defined(KINETISL)\n                return IRQ_PIT;\n                #endif\n        }\n        return (IRQ_NUMBER_t)NVIC_NUM_INTERRUPTS;\n}\n\n#if defined(KINETISK)\nvoid pit0_isr()\n{\n        PIT_TFLG0 = 1;\n        if (funct_table[0]   !dealloc_on_exit[0])\n                funct_table[0]();\n        if (dealloc_on_exit[0]) {\n                dealloc_on_exit[0]- deallocResources();\n                dealloc_on_exit[0] = nullptr;\n        }\n}\n\nvoid pit1_isr() {\n        PIT_TFLG1 = 1;\n        if (funct_table[1]   !dealloc_on_exit[1])\n                funct_table[1]();\n        if (dealloc_on_exit[1]) {\n                dealloc_on_exit[1]- deallocResources();\n                dealloc_on_exit[1] = nullptr;\n        }\n}\n\nvoid pit2_isr() {\n        PIT_TFLG2 = 1;\n        if (funct_table[2]   !dealloc_on_exit[2])\n                funct_table[2]();\n        if (dealloc_on_exit[2]) {\n                dealloc_on_exit[2]- deallocResources();\n                dealloc_on_exit[2] = nullptr;\n        }\n}\n\nvoid pit3_isr() {\n        PIT_TFLG3 = 1;\n        if (funct_table[3]   !dealloc_on_exit[3])\n                funct_table[3]();\n        if (dealloc_on_exit[3]) {\n                dealloc_on_exit[3]- deallocResources();\n                dealloc_on_exit[3] = nullptr;\n        }\n}\n\n#elif defined(KINETISL)\nvoid pit_isr() {\n        if (PIT_TFLG0) {\n                PIT_TFLG0 = 1;\n                if (funct_table[0])\n                        funct_table[0]();\n        }\n        if (PIT_TFLG1) {\n                PIT_TFLG1 = 1;\n                if (funct_table[1])\n                        funct_table[1]();\n        }\n}\n#endif", 
            "title": "LambdaTimer"
        }, 
        {
            "location": "/#dispatchafter", 
            "text": "This is a wrapper around a LambdaTimer that calls you back once after a certain interval has elapsed and hen deallocated the timer. It\u2019s simple code, but saves having to do manual deallocation over and over.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LambdaTimer.hpp\"\n\nclass DispatchAfter{\npublic:\n        void schedule(uint32_t microseconds, std::function void()  callback);\n\n        void cancel();\nprivate:\n        LambdaTimer timer;\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"DispatchAfter.hpp\"\n\n#include  Arduino.h \n\n\nvoid DispatchAfter::schedule(uint32_t microseconds, std::function void()  callback) {\n        bool success = timer.begin(microseconds, [this, callback]() {\n                callback();\n            timer.end();\n        });\n        if (!success) {\n                Serial.println(\"Timer Failed.\");\n        }\n}\n\nvoid DispatchAfter::cancel() {\n        timer.end();\n}", 
            "title": "DispatchAfter"
        }, 
        {
            "location": "/#missingsystemfunctions", 
            "text": "The C++ standard libraries are designed to run on an OS. We can\u2019t get our program to link unless we have some basic functions those libraries assume. This code fakes like our bare metal code running on an OS.  //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include  Arduino.h \n\n// Add in stdlib's missing dependencies.\n// These functions are thing's the code would expect on an OS, but we're\n// running bare metal.\n\nextern \"C\" { // no name mangling\n\n        // No processes, so no killing...\n        int _kill(int pid, int sig) {\n                Serial.printf(\"Process %d sent signal %d.\", pid, sig);\n                return -1; // Error, since we can't kill.\n        }\n\n        // There is only one process...with ID 1!\n        int _getpid() {\n                return 1;\n        }\n\n        // Ah...life without a file system.\n        int _write() {\n                return -1;\n        }\n}", 
            "title": "MissingSystemFunctions"
        }, 
        {
            "location": "/#hardware-libraries", 
            "text": "With all that infrastructure built, it\u2019s much easier to build clean abstractions for each hardware subsystem of our robot. Here are the implementations:", 
            "title": "Hardware Libraries"
        }, 
        {
            "location": "/#tapesensor", 
            "text": "This class manages notifying the main program of when various colors of tape are crossed. It also manages (and hides) de-noising crossings of things like cracks and skid marks that mar the course. It does so via an easily adjustable tight upper bound on the time taken to cross a tape line.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LambdaTimer.hpp\"\n\nclass TapeSensor {\npublic:\n        TapeSensor(uint8_t analog_input_pin, uint32_t min_crossing_duration);\n\n        void observeBlack(std::function void()  on_black);\n        void observeGrey(std::function void()  on_grey);\n        void observeGreen(std::function void()  on_green);\n\n        void stopObserving();\n\nprivate:\n        void startTimerIfNeeded();\n\n        enum class Tape { UNKNOWN, WHITE, BLACK, GREY, GREEN };\n        Tape last_seen, last_last_seen;\n\n        const uint8_t analog_input_pin;\n        const uint32_t timer_duration;\n\n        LambdaTimer sensor_poll_timer;\n        std::function void()  on_black;\n        std::function void()  on_grey;\n        std::function void()  on_green;\n        bool black_active, grey_active, green_active;\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"TapeSensor.hpp\"\n\n#include  Arduino.h \n\n\nTapeSensor::TapeSensor(uint8_t analog_input_pin, uint32_t min_crossing_duration) :\nlast_seen(Tape::UNKNOWN),\nlast_last_seen(Tape::UNKNOWN),\nanalog_input_pin(analog_input_pin),\ntimer_duration(min_crossing_duration/2), // So we're guaranteed to get 2 samples on it.\nblack_active(false), grey_active(false), green_active(false)\n{\n        pinMode(analog_input_pin, INPUT);\n}\n\nvoid TapeSensor::observeBlack(std::function void()  on_black) {\n        this- on_black = on_black;\n        black_active = true;\n        startTimerIfNeeded();\n}\n\nvoid TapeSensor::observeGrey(std::function void()  on_grey) {\n        this- on_grey = on_grey;\n        grey_active = true;\n        startTimerIfNeeded();\n}\n\nvoid TapeSensor::observeGreen(std::function void()  on_green) {\n        this- on_green = on_green;\n        green_active = true;\n        startTimerIfNeeded();\n}\n\nvoid TapeSensor::stopObserving() {\n        sensor_poll_timer.end();\n        last_seen = Tape::UNKNOWN;\n        last_last_seen = Tape::UNKNOWN;\n\n        black_active = grey_active = green_active = false;\n}\n\nvoid TapeSensor::startTimerIfNeeded() {\n        if (!sensor_poll_timer.active()) {\n                sensor_poll_timer.begin(timer_duration, [this] {\n                        static const uint16_t WHITE_GREEN_THRESH = 825;\n                        static const uint16_t GREEN_GREY_THRESH = 500; //below crack thresh\n                        static const uint16_t GREY_BLACK_THRESH = 200;\n\n                        uint16_t reading = analogRead(analog_input_pin);\n                    // Serial.print(reading); Serial.print(\"\\t\"); Serial.println(black_active);\n\n                        Tape seen = Tape::WHITE;\n                        if (reading   GREY_BLACK_THRESH) {\n                                seen = Tape::BLACK;\n                        } else if (reading   GREEN_GREY_THRESH) {\n                                seen = Tape::GREY;\n                        } else if (reading   WHITE_GREEN_THRESH) {\n                                seen = Tape::GREEN;\n                        }\n\n                        if (last_last_seen != last_seen   last_seen == seen) {\n                                if (seen == Tape::BLACK   black_active) {\n                                        on_black();\n                                        Serial.println(\"Seen black\");\n                                } else if (seen == Tape::GREY   grey_active) {\n                                        on_grey();\n                                        Serial.println(\"Seen grey\");\n                                } else if (seen == Tape::GREEN   green_active) {\n                                        on_green();\n                                        Serial.println(\"Seen green\");\n                                }\n                        }\n\n                        last_last_seen = last_seen;\n                        last_seen = seen;\n                });\n        }\n}", 
            "title": "TapeSensor"
        }, 
        {
            "location": "/#drivemotor", 
            "text": "This class controls a motor and its interaction with the limit switches tracking its position. It provides a lot of the tracking and stopping primitives that make the main code so simple.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DispatchAfter.hpp\"\n\n// Limit switch is considered the positive direction of motion.\n// Set polarity to make that so.\n\nclass DriveMotor {\npublic:\n        DriveMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity, uint8_t limit_switch_pin, uint8_t negative_limit_switch_pin = -1);\n\n        void timedMove(int directional_speed, uint32_t duration_micros, std::function void()  completionHandler);\n        void moveToLimit(int speed, std::function void()  completionHandler);\n\n        void trackPositiveLimit(int speed);\n        void stopTrackingPositiveLimit();\n\n        void notifyOnNextNegativeLimitPress(std::function void()  pressed);\n\n        void move(int directional_speed);\n        void stop();\n\n        // Call me on 2:10 timer expiring.\n        void disable();\n\nprivate:\n        bool enabled;\n\n        const uint8_t bridge_pin_1;\n        const uint8_t bridge_pin_2;\n        const uint8_t enable_pin_pwm;\n        const bool polarity;\n        const uint8_t limit_switch_pin;\n        const uint8_t negative_limit_switch_pin;\n\n        DispatchAfter stop_dispatch;\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DriveMotor.hpp\"\n#include \"LambdaInterrupt.hpp\"\n\n#include  Arduino.h \n\n\nDriveMotor::DriveMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity, uint8_t limit_switch_pin, uint8_t negative_limit_switch_pin) :\nenabled(true),\nbridge_pin_1(bridge_pin_1),\nbridge_pin_2(bridge_pin_2),\nenable_pin_pwm(enable_pin_pwm),\npolarity(polarity),\nlimit_switch_pin(limit_switch_pin),\nnegative_limit_switch_pin(negative_limit_switch_pin)\n{\n        pinMode(bridge_pin_1, OUTPUT);\n        pinMode(bridge_pin_2, OUTPUT);\n        pinMode(enable_pin_pwm, OUTPUT);\n        stop();\n        pinMode(limit_switch_pin, INPUT_PULLUP);\n        if (negative_limit_switch_pin  = 0)\n                pinMode(negative_limit_switch_pin, INPUT_PULLUP);\n}\n\nvoid DriveMotor::timedMove(int directional_speed, uint32_t duration_micros, std::function void()  completionHandler) {\n        move(directional_speed);\n        stop_dispatch.schedule(duration_micros, [this, completionHandler]() {\n                stop();\n                completionHandler();\n        });\n}\n\nvoid DriveMotor::notifyOnNextNegativeLimitPress(std::function void()  pressed) {\n        LambdaInterrupt::attach(negative_limit_switch_pin, FALLING, [this, pressed] () {\n                LambdaInterrupt::detatch(negative_limit_switch_pin);\n                pressed();\n        });\n}\n\nvoid DriveMotor::moveToLimit(int speed, std::function void()  completionHandler) {\n        uint8_t limit_pin = limit_switch_pin;\n\n        if (speed   0) {\n                if (negative_limit_switch_pin   0) {\n                        Serial.println(\"Attempt to use negative limit without a negative limit switch configured.\");\n                        completionHandler();\n                        return;\n                }\n\n                limit_pin = negative_limit_switch_pin;\n        }\n\n        if (digitalRead(limit_pin) == LOW) {\n                completionHandler();\n        } else {\n                move(speed);\n                LambdaInterrupt::attach(limit_pin, FALLING, [this, completionHandler, limit_pin] () {\n                        LambdaInterrupt::detatch(limit_pin);\n                        stop();\n                        completionHandler();\n                });\n        }\n}\n\nvoid DriveMotor::trackPositiveLimit(int speed) {\n        if (speed   0)\n                speed = -speed;\n\n        move(speed);\n        LambdaInterrupt::attach(limit_switch_pin, CHANGE, [this, speed] () {\n                if (digitalRead(limit_switch_pin) == HIGH) {\n                        move(speed);\n                } else {\n                        stop();\n                }\n        });\n}\n\nvoid DriveMotor::stopTrackingPositiveLimit() {\n        stop();\n        LambdaInterrupt::detatch(limit_switch_pin);\n}\n\nvoid DriveMotor::disable() {\n        stopTrackingPositiveLimit();\n        stop_dispatch.cancel();\n        stop();\n        enabled = false;\n}\n\nvoid DriveMotor::move(int directional_speed) {\n        if (!enabled) return;\n\n        if (polarity)\n                directional_speed = -directional_speed;\n\n        if (directional_speed   0) {\n                digitalWrite(bridge_pin_1, HIGH);\n                digitalWrite(bridge_pin_2, LOW);\n        } else {\n                digitalWrite(bridge_pin_1, LOW);\n                digitalWrite(bridge_pin_2, HIGH);\n                directional_speed = -directional_speed; //abs\n        }\n\n        analogWrite(enable_pin_pwm, directional_speed);\n}\n\nvoid DriveMotor::stop() {\n        analogWrite(enable_pin_pwm, 0);\n}", 
            "title": "DriveMotor"
        }, 
        {
            "location": "/#launchtube", 
            "text": "This class manages launching balls, counting the number of balls loaded, and notifying the main program on reload. We instantiate it twice, one for each physical tube.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DebouncedInterrupt.hpp\"\n#include \"DispatchAfter.hpp\"\n\n// Handles all the work associated with managing a launch tube.\n// (debouncing, initialization, resetting solenoids, etc.)\n// Just sit back and enjoy the interface.\n\n// Note: Class assumes it will not be destructed for the lifetime of the program.\n\nclass LaunchTube {\npublic:\n        LaunchTube(uint8_t solenoid_pin, uint8_t limit_switch_pin, uint8_t starting_balls);\n\n        void dumpBallsPresent(std::function void()  completionHandler);\n        void dumpOneBallPresent(std::function void()  completionHandler);\n\n        void notifyOnNextLoad(std::function void()  loaded);\n\n        bool hasBalls();\n\n        // Call me on timer expiring.\n        void disable();\n\nprivate:\n        void dumpNBallsPresent(int nBalls, std::function void()  completionHandler);\n        void solenoidIn();\n        void solenoidOut();\n\n        bool enabled;\n        DispatchAfter solenoid_shutoff;\n        const uint8_t solenoid_pin;\n        int num_balls;\n        DebouncedInterrupt limit_switch_notifier;\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"LaunchTube.hpp\"\n\n#include  Arduino.h \n\nstatic int calcDispenseTime(int numBalls) {\n  static const int INTERCEPT = 80000; // Add some safety margin\n  static const int SLOPE = 50000;\n  return SLOPE*numBalls + INTERCEPT;\n}\n\n\nLaunchTube::LaunchTube(uint8_t solenoid_pin, uint8_t limit_switch_pin, uint8_t starting_balls) :\n        enabled(true),\n        solenoid_pin(solenoid_pin),\n        num_balls(starting_balls),\n        limit_switch_notifier(limit_switch_pin, INPUT_PULLUP, FALLING, 60000 /*us*/, [this]() {\n                num_balls++;\n        })\n{\n        pinMode(solenoid_pin, OUTPUT);\n        solenoidOut();\n}\n\nvoid LaunchTube::dumpNBallsPresent(int nBalls, std::function void()  completionHandler) {\n        if (!enabled) return;\n\n        if (num_balls == 0){\n                completionHandler();\n        } else {\n                solenoidIn();\n                solenoid_shutoff.schedule(calcDispenseTime(nBalls), [this, completionHandler]() {\n                        solenoidOut();\n                        completionHandler();\n                });\n            num_balls -= nBalls;\n        }\n}\n\nvoid LaunchTube::dumpBallsPresent(std::function void()  completionHandler) {\n        dumpNBallsPresent(num_balls, completionHandler);\n}\n\nvoid LaunchTube::dumpOneBallPresent(std::function void()  completionHandler) {\n        dumpNBallsPresent(1, completionHandler);\n}\n\nvoid LaunchTube::notifyOnNextLoad(std::function void()  loaded) {\n        limit_switch_notifier.dispatchAfterBurstFinish(0.3*1000000, loaded);\n}\n\nbool LaunchTube::hasBalls() {\n        return num_balls   0;\n}\n\nvoid LaunchTube::disable() {\n        limit_switch_notifier.disable();\n        enabled = false;\n        // Solenoids will get automatically relaxed as time expires.\n        // That way the robot will cease all action at the timer\n        // including stopping, except as to save power.\n}\n\nvoid LaunchTube::solenoidIn() {\n        digitalWrite(solenoid_pin, HIGH);\n}\n\nvoid LaunchTube::solenoidOut() {\n        digitalWrite(solenoid_pin, LOW);\n}", 
            "title": "LaunchTube"
        }, 
        {
            "location": "/#tippermotor", 
            "text": "This class manages raising and lowering the tipper arm asynchronously, which we do with a simple timer and stall. There\u2019s a double timer backing off raising the tipper so the spring force doesn't cause the tipper to bounce back away from the top limit.  #pragma once\n//             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n#include \"DispatchAfter.hpp\"\n\nclass TipperMotor {\npublic:\n        TipperMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity);\n\n        void up();\n        void down();\n\n        // Call me on 2:10 timer expiring.\n        void disable();\n\nprivate:\n        void move(int directional_speed);\n        void stop();\n\n        bool enabled;\n\n        const uint8_t bridge_pin_1;\n        const uint8_t bridge_pin_2;\n        const uint8_t enable_pin_pwm;\n        const bool polarity;\n\n        DispatchAfter stop_dispatch, hold_dispatch;\n};   //             __  _________   ___  _______\n//            /  |/  / ____/  |__ \\   / __ \\\n//           / /|_/ / __/     __/ // / / / /\n//          / /  / / /___    / __// / /_/ /\n//        _///__/_/_____/   /____/_/\\___//__\n//       /_  __/__  ____ _____ ___     / __ \\\n//        / / / _ \\/ __ `/ __ `__ \\   / / / /\n//       / / /  __/ /_/ / / / / / /  / /_/ /\n//      /_/  \\___/\\__,_/_/ /_/ /_/   \\____/\n//\n//            Don't be first. Be zeroth.\n//       (c) Kyle, Shalini, Christopher, Joe\n\n\n#include \"TipperMotor.hpp\"\n\n#include  Arduino.h \n\n\nTipperMotor::TipperMotor(uint8_t bridge_pin_1, uint8_t bridge_pin_2, uint8_t enable_pin_pwm, bool polarity) :\nbridge_pin_1(bridge_pin_1),\nbridge_pin_2(bridge_pin_2),\nenable_pin_pwm(enable_pin_pwm),\npolarity(polarity)\n{\n        pinMode(bridge_pin_1, OUTPUT);\n        pinMode(bridge_pin_2, OUTPUT);\n        pinMode(enable_pin_pwm, OUTPUT);\n        stop();\n}\n\nvoid TipperMotor::up() {\n        move(1023);\n        stop_dispatch.schedule(1*1000000, [this]() {\n                move(100);\n                hold_dispatch.schedule(1.5*1000000, [this]() {\n                        stop();\n                });\n        });\n}\n\nvoid TipperMotor::down() {\n        move(-1023);\n        stop_dispatch.schedule(0.48*1000000, [this]() {\n                stop();\n        });\n}\n\nvoid TipperMotor::disable() {\n        stop_dispatch.cancel();\n        stop();\n}\n\nvoid TipperMotor::move(int directional_speed) {\n        if (polarity)\n                directional_speed = -directional_speed;\n\n        if (directional_speed   0) {\n                digitalWrite(bridge_pin_1, HIGH);\n                digitalWrite(bridge_pin_2, LOW);\n        } else {\n                digitalWrite(bridge_pin_1, LOW);\n                digitalWrite(bridge_pin_2, HIGH);\n                directional_speed = -directional_speed; //abs\n        }\n\n        analogWrite(enable_pin_pwm, directional_speed);\n}\n\nvoid TipperMotor::stop() {\n        analogWrite(enable_pin_pwm, 0);\n}", 
            "title": "TipperMotor"
        }, 
        {
            "location": "/#build-notes", 
            "text": "If you want to compile the above code, there are some changes you need to make to the Arduino environment.  We need to link against the C++ standard libraries for the lambdas in our interrupt driven code. Link against it like so:  On macOS, open terminal and run:  open /Applications/Arduino.app/Contents/Java/hardware/teensy/avr/boards.txt  Equivalent windows path:  C:\\Program Files (x86)\\Arduino\\hardware\\teensy\\avr\\boards.txt  Change  teensy31.build.flags.libs=-larm_cortexM4l_math -lm  to  teensy31.build.flags.libs=-lstdc++ -larm_cortexM4l_math -lm  You (of course) need to have installed Teensy\u2019s dev environment inside of Arduino.  Within it, do not turn on link-time optimization (LTO). There is a bug that invalidates lambdas.\nTools\u2192Optimize should be set to \u201cFastest\u201d. If that\u2019s taking up too much program memory, switch to \u201cSmallest\u201d for a dramatic reduction on program size.", 
            "title": "Build Notes"
        }, 
        {
            "location": "/#code-download", 
            "text": "The full, zipped sketch can be downloaded  here .", 
            "title": "Code Download"
        }, 
        {
            "location": "/#robot-fabrication", 
            "text": "", 
            "title": "Robot Fabrication"
        }, 
        {
            "location": "/#system-layout-and-integration-using-3d-cad", 
            "text": "MASTER%20ASSEM%20%28Converted%29.mov  The robot was structured around a three tiered system. We first decided to do a single global layout file to dictate locations for all the elements of the system. This ensured that from the start we could prevent interferences that are often the downfall of semi-complex integrated systems. From this master file, we were able to break out individual parts using an interlocking tab design for laser cutting. The standoffs that hold the drive axles are captive between the first and second deck which are clamped with threaded rods. Working from the ground up, we integrated a skirt to prevent debris on the game board from interfering with the drive system. In between the first and second decks of the robot, we placed the mechanical drive system. The second deck had the motors and gearheads placed closely to two motor driver modules, tape sensor, beacon circuit and limit switches through internal built in wiring pass throughs in the deck. Mounting points were integrated in the CAD model to create laser cut parts that were easy to assemble.  We put clean wire layout as an important design consideration opting for ribbon bales and tape tie downs throughout the robot. The teensy was placed in the center and connected to the motor driver modules. The level also supported a brace for the ball depositing mechanism and solenoid mounts. The batteries were placed such that they would counter the mass of the motors and provide a roughly centered center of gravity. The third and highest deck supported the upper side of the solenoid mounts and ball depositing system as well as the tipper drive and beacon sensing system.     CAD master layout.", 
            "title": "System Layout and Integration using 3D CAD"
        }, 
        {
            "location": "/#drive-deck", 
            "text": "Collars prevent axial motion of the drive system which prevents the wheels and gears from rubbing on the chassis.   Cut outs in the bottom allow the wheels and gears more space and make tightening set screws easier during assembly.", 
            "title": "Drive deck"
        }, 
        {
            "location": "/#electrical-system-deck", 
            "text": "The e-stop is easily accessible from the side. Side by side pins were routed to side by side pins on the teensy for clean wiring.   Drive motor and gearhead offer a 51:1 reduction.   The solenoids are held captive in vertical members and locked in place using a nut.", 
            "title": "Electrical system deck"
        }, 
        {
            "location": "/#top-deck", 
            "text": "Green tape holding together a cracked gear housing. The free bin is always a mixed bag.", 
            "title": "Top deck"
        }, 
        {
            "location": "/#manufacturing", 
            "text": "Front view shows base construction, welded tipping arm, machined ball tubes, and laser-cut duron layers.  While the base and support structure were a relatively standard threaded rod and lasercut duron approach, we used more advanced manufacturing strategies for our tipping mechanism and ball dispensing mechanism to ensure reliability.  The ball dispensing tubes have machined slots and holes in precise locations, so that the limit switches and solenoids sat reliably in place for proper actuation. Our alignment pins for these tubes were out of spec, so the tubes moved slightly, causing the solenoids to bind and the limit switches to not trigger; however, we were able to fix this by realigning and locking the tubes in place.  The tipper arm was the most difficult manufacturing challenge on our robot, and was the most fun to create. Do to the 12\u201d cubic bounding box defined by the project and the amount of force we wanted from the arm, we decided to make it out of steel and aluminum. The arm was a welded steel lever that had a thickened plate at the tip for consistent tipping, and holes for a hinge and pulley string. When discussing welding Chris, wanted to weld so we taught him how and he welded the final tipper arm.  Additionally, we formed the spring for the arm out of 1/16\u201d spring steel wire, machined the aluminum attachment bracket, turned and machined angled washers for angle adjustment, wood turned the pulley and formed the two brackets for ensuring proper extension and retraction of the arm. Using a variety of processes, we were able to explore our interests and solve problems not easily fixed by a laser cutter. These reliable and robust systems allowed us to run the robot for 5-10 rounds before rechecking all the critical functions using a \u2018pit stop\u2019 checklist, and only using a short pre-round checkoff list each time.", 
            "title": "Manufacturing"
        }
    ]
}